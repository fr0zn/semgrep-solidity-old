(* Generated by ocaml-tree-sitter. *)
(*
   solidity grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type int_ = [
    `Int of Token.t (* "int" *)
  | `Int8 of Token.t (* "int8" *)
  | `Int16 of Token.t (* "int16" *)
  | `Int24 of Token.t (* "int24" *)
  | `Int32 of Token.t (* "int32" *)
  | `Int40 of Token.t (* "int40" *)
  | `Int48 of Token.t (* "int48" *)
  | `Int56 of Token.t (* "int56" *)
  | `Int64 of Token.t (* "int64" *)
  | `Int72 of Token.t (* "int72" *)
  | `Int80 of Token.t (* "int80" *)
  | `Int88 of Token.t (* "int88" *)
  | `Int96 of Token.t (* "int96" *)
  | `Int104 of Token.t (* "int104" *)
  | `Int112 of Token.t (* "int112" *)
  | `Int120 of Token.t (* "int120" *)
  | `Int128 of Token.t (* "int128" *)
  | `Int136 of Token.t (* "int136" *)
  | `Int144 of Token.t (* "int144" *)
  | `Int152 of Token.t (* "int152" *)
  | `Int160 of Token.t (* "int160" *)
  | `Int168 of Token.t (* "int168" *)
  | `Int176 of Token.t (* "int176" *)
  | `Int184 of Token.t (* "int184" *)
  | `Int192 of Token.t (* "int192" *)
  | `Int200 of Token.t (* "int200" *)
  | `Int208 of Token.t (* "int208" *)
  | `Int216 of Token.t (* "int216" *)
  | `Int224 of Token.t (* "int224" *)
  | `Int232 of Token.t (* "int232" *)
  | `Int240 of Token.t (* "int240" *)
  | `Int248 of Token.t (* "int248" *)
  | `Int256 of Token.t (* "int256" *)
]
[@@deriving sexp_of]

type pat_a096c41 = Token.t (* pattern "[^'\\r\\n\\\\]" *)
[@@deriving sexp_of]

type yul_identifier = Token.t (* pattern [a-zA-Z$_]+ *)
[@@deriving sexp_of]

type yul_boolean = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]
[@@deriving sexp_of]

type yul_decimal_number = Token.t (* pattern 0|([1-9][0-9]*\
  ) *)
[@@deriving sexp_of]

type number_unit = [
    `Wei of Token.t (* "wei" *)
  | `Szabo of Token.t (* "szabo" *)
  | `Finney of Token.t (* "finney" *)
  | `Gwei of Token.t (* "gwei" *)
  | `Ether of Token.t (* "ether" *)
  | `Seconds of Token.t (* "seconds" *)
  | `Minutes of Token.t (* "minutes" *)
  | `Hours of Token.t (* "hours" *)
  | `Days of Token.t (* "days" *)
  | `Weeks of Token.t (* "weeks" *)
  | `Years of Token.t (* "years" *)
]
[@@deriving sexp_of]

type solidity_version_comparison_operator = [
    `LTEQ of Token.t (* "<=" *)
  | `LT of Token.t (* "<" *)
  | `HAT of Token.t (* "^" *)
  | `GT of Token.t (* ">" *)
  | `GTEQ of Token.t (* ">=" *)
  | `TILDE of Token.t (* "~" *)
  | `EQ of Token.t (* "=" *)
]
[@@deriving sexp_of]

type experimental_directives = [
    `ABIE2 of Token.t (* "ABIEncoderV2" *)
  | `SMTC of Token.t (* "SMTChecker" *)
]
[@@deriving sexp_of]

type pat_f2662db = Token.t (* pattern fixed([0-9]+)x([0-9]+) *)
[@@deriving sexp_of]

type solidity_version = Token.t (* pattern \d+(.\d+(.\d+)?)? *)
[@@deriving sexp_of]

type pat_6c32705 = Token.t (* pattern \d+(\.\d+)?([eE](-)?\d+)? *)
[@@deriving sexp_of]

type imm_tok_pat_de5d470 = Token.t (* pattern "[^\"\\\\\\n]+|\\\\\\r?\\n" *)
[@@deriving sexp_of]

type yul_hex_number = Token.t (* pattern 0x[0-9A-Fa-f]* *)
[@@deriving sexp_of]

type pat_0c477de = Token.t (* pattern "[^\"\\r\\n\\\\]" *)
[@@deriving sexp_of]

type pat_accdbe2 = Token.t (* pattern ufixed([0-9]+)x([0-9]+) *)
[@@deriving sexp_of]

type storage_location = [
    `Memory of Token.t (* "memory" *)
  | `Stor of Token.t (* "storage" *)
  | `Call of Token.t (* "calldata" *)
]
[@@deriving sexp_of]

type visibility = [
    `Public of Token.t (* "public" *)
  | `Inte of Token.t (* "internal" *)
  | `Priv of Token.t (* "private" *)
  | `Exte of Token.t (* "external" *)
]
[@@deriving sexp_of]

type uint = [
    `Uint of Token.t (* "uint" *)
  | `Uint8 of Token.t (* "uint8" *)
  | `Uint16 of Token.t (* "uint16" *)
  | `Uint24 of Token.t (* "uint24" *)
  | `Uint32 of Token.t (* "uint32" *)
  | `Uint40 of Token.t (* "uint40" *)
  | `Uint48 of Token.t (* "uint48" *)
  | `Uint56 of Token.t (* "uint56" *)
  | `Uint64 of Token.t (* "uint64" *)
  | `Uint72 of Token.t (* "uint72" *)
  | `Uint80 of Token.t (* "uint80" *)
  | `Uint88 of Token.t (* "uint88" *)
  | `Uint96 of Token.t (* "uint96" *)
  | `Uint104 of Token.t (* "uint104" *)
  | `Uint112 of Token.t (* "uint112" *)
  | `Uint120 of Token.t (* "uint120" *)
  | `Uint128 of Token.t (* "uint128" *)
  | `Uint136 of Token.t (* "uint136" *)
  | `Uint144 of Token.t (* "uint144" *)
  | `Uint152 of Token.t (* "uint152" *)
  | `Uint160 of Token.t (* "uint160" *)
  | `Uint168 of Token.t (* "uint168" *)
  | `Uint176 of Token.t (* "uint176" *)
  | `Uint184 of Token.t (* "uint184" *)
  | `Uint192 of Token.t (* "uint192" *)
  | `Uint200 of Token.t (* "uint200" *)
  | `Uint208 of Token.t (* "uint208" *)
  | `Uint216 of Token.t (* "uint216" *)
  | `Uint224 of Token.t (* "uint224" *)
  | `Uint232 of Token.t (* "uint232" *)
  | `Uint240 of Token.t (* "uint240" *)
  | `Uint248 of Token.t (* "uint248" *)
  | `Uint256 of Token.t (* "uint256" *)
]
[@@deriving sexp_of]

type escape_sequence = Token.t
[@@deriving sexp_of]

type identifier = Token.t (* pattern [a-zA-Z$_][a-zA-Z0-9$_]* *)
[@@deriving sexp_of]

type bytes_ = [
    `Byte of Token.t (* "byte" *)
  | `Bytes of Token.t (* "bytes" *)
  | `Bytes1 of Token.t (* "bytes1" *)
  | `Bytes2 of Token.t (* "bytes2" *)
  | `Bytes3 of Token.t (* "bytes3" *)
  | `Bytes4 of Token.t (* "bytes4" *)
  | `Bytes5 of Token.t (* "bytes5" *)
  | `Bytes6 of Token.t (* "bytes6" *)
  | `Bytes7 of Token.t (* "bytes7" *)
  | `Bytes8 of Token.t (* "bytes8" *)
  | `Bytes9 of Token.t (* "bytes9" *)
  | `Bytes10 of Token.t (* "bytes10" *)
  | `Bytes11 of Token.t (* "bytes11" *)
  | `Bytes12 of Token.t (* "bytes12" *)
  | `Bytes13 of Token.t (* "bytes13" *)
  | `Bytes14 of Token.t (* "bytes14" *)
  | `Bytes15 of Token.t (* "bytes15" *)
  | `Bytes16 of Token.t (* "bytes16" *)
  | `Bytes17 of Token.t (* "bytes17" *)
  | `Bytes18 of Token.t (* "bytes18" *)
  | `Bytes19 of Token.t (* "bytes19" *)
  | `Bytes20 of Token.t (* "bytes20" *)
  | `Bytes21 of Token.t (* "bytes21" *)
  | `Bytes22 of Token.t (* "bytes22" *)
  | `Bytes23 of Token.t (* "bytes23" *)
  | `Bytes24 of Token.t (* "bytes24" *)
  | `Bytes25 of Token.t (* "bytes25" *)
  | `Bytes26 of Token.t (* "bytes26" *)
  | `Bytes27 of Token.t (* "bytes27" *)
  | `Bytes28 of Token.t (* "bytes28" *)
  | `Bytes29 of Token.t (* "bytes29" *)
  | `Bytes30 of Token.t (* "bytes30" *)
  | `Bytes31 of Token.t (* "bytes31" *)
  | `Bytes32 of Token.t (* "bytes32" *)
]
[@@deriving sexp_of]

type anon_choice_PLUSPLUS_e498e28 = [
    `PLUSPLUS of Token.t (* "++" *)
  | `DASHDASH of Token.t (* "--" *)
]
[@@deriving sexp_of]

type pat_0468c4a = Token.t (* pattern \.\d+([eE](-)?\d+)? *)
[@@deriving sexp_of]

type hex_digit = Token.t (* pattern [\da-fA-F] *)
[@@deriving sexp_of]

type pat_923b015 = Token.t (* pattern 0[xX] *)
[@@deriving sexp_of]

type state_mutability = [
    `Pure of Token.t (* "pure" *)
  | `View of Token.t (* "view" *)
  | `Paya of Token.t (* "payable" *)
]
[@@deriving sexp_of]

type yul_evm_builtin = [
    `Stop of Token.t (* "stop" *)
  | `Add of Token.t (* "add" *)
  | `Sub of Token.t (* "sub" *)
  | `Mul of Token.t (* "mul" *)
  | `Div of Token.t (* "div" *)
  | `Sdiv of Token.t (* "sdiv" *)
  | `Mod of Token.t (* "mod" *)
  | `Smod of Token.t (* "smod" *)
  | `Exp of Token.t (* "exp" *)
  | `Not of Token.t (* "not" *)
  | `Lt of Token.t (* "lt" *)
  | `Gt of Token.t (* "gt" *)
  | `Slt of Token.t (* "slt" *)
  | `Sgt of Token.t (* "sgt" *)
  | `Eq of Token.t (* "eq" *)
  | `Iszero of Token.t (* "iszero" *)
  | `And of Token.t (* "and" *)
  | `Or of Token.t (* "or" *)
  | `Xor of Token.t (* "xor" *)
  | `Byte of Token.t (* "byte" *)
  | `Shl of Token.t (* "shl" *)
  | `Shr of Token.t (* "shr" *)
  | `Sar of Token.t (* "sar" *)
  | `Addmod of Token.t (* "addmod" *)
  | `Mulmod of Token.t (* "mulmod" *)
  | `Sign of Token.t (* "signextend" *)
  | `Keccak256 of Token.t (* "keccak256" *)
  | `Pop of Token.t (* "pop" *)
  | `Mload of Token.t (* "mload" *)
  | `Mstore of Token.t (* "mstore" *)
  | `Mstore8 of Token.t (* "mstore8" *)
  | `Sload of Token.t (* "sload" *)
  | `Sstore of Token.t (* "sstore" *)
  | `Msize of Token.t (* "msize" *)
  | `Gas of Token.t (* "gas" *)
  | `Addr of Token.t (* "address" *)
  | `Bala of Token.t (* "balance" *)
  | `Self_e34af40 of Token.t (* "selfbalance" *)
  | `Caller of Token.t (* "caller" *)
  | `Call_17bffc7 of Token.t (* "callvalue" *)
  | `Call_b766e35 of Token.t (* "calldataload" *)
  | `Call_ee2b8b2 of Token.t (* "calldatasize" *)
  | `Call_9211e8b of Token.t (* "calldatacopy" *)
  | `Extc_8cf31ff of Token.t (* "extcodesize" *)
  | `Extc_097e5c5 of Token.t (* "extcodecopy" *)
  | `Retu_6316777 of Token.t (* "returndatasize" *)
  | `Retu_0c570b4 of Token.t (* "returndatacopy" *)
  | `Extc_d7340e7 of Token.t (* "extcodehash" *)
  | `Create of Token.t (* "create" *)
  | `Create2 of Token.t (* "create2" *)
  | `Call_53b9e96 of Token.t (* "call" *)
  | `Call_bebd5bc of Token.t (* "callcode" *)
  | `Dele of Token.t (* "delegatecall" *)
  | `Stat of Token.t (* "staticcall" *)
  | `Ret of Token.t (* "return" *)
  | `Revert of Token.t (* "revert" *)
  | `Self_482b767 of Token.t (* "selfdestruct" *)
  | `Inva of Token.t (* "invalid" *)
  | `Log0 of Token.t (* "log0" *)
  | `Log1 of Token.t (* "log1" *)
  | `Log2 of Token.t (* "log2" *)
  | `Log3 of Token.t (* "log3" *)
  | `Log4 of Token.t (* "log4" *)
  | `Chai of Token.t (* "chainid" *)
  | `Origin of Token.t (* "origin" *)
  | `Gasp of Token.t (* "gasprice" *)
  | `Bloc of Token.t (* "blockhash" *)
  | `Coin of Token.t (* "coinbase" *)
  | `Time of Token.t (* "timestamp" *)
  | `Num of Token.t (* "number" *)
  | `Diff of Token.t (* "difficulty" *)
  | `Gasl of Token.t (* "gaslimit" *)
]
[@@deriving sexp_of]

type imm_tok_pat_3e57880 = Token.t (* pattern "[^'\\\\\\n]+|\\\\\\r?\\n" *)
[@@deriving sexp_of]

type yul_path = (
    yul_identifier (*tok*)
  * (Token.t (* "." *) * yul_identifier (*tok*)) list (* zero or more *)
)
[@@deriving sexp_of]

type anon_yul_id_rep_COMMA_yul_id_opt_COMMA_477546e = (
    yul_identifier (*tok*)
  * (Token.t (* "," *) * yul_identifier (*tok*)) list (* zero or more *)
  * Token.t (* "," *) option
)
[@@deriving sexp_of]

type experimental_directive = (
    Token.t (* "experimental" *)
  * Token.t (* "\"" *) option
  * experimental_directives
  * Token.t (* "\"" *) option
)
[@@deriving sexp_of]

type fixed = [
    `Fixed of Token.t (* "fixed" *)
  | `Pat_f2662db of pat_f2662db (*tok*)
]
[@@deriving sexp_of]

type boolean_literal = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]
[@@deriving sexp_of]

type pragma_version_constraint = (
    solidity_version_comparison_operator option
  * solidity_version (*tok*)
)
[@@deriving sexp_of]

type ufixed = [
    `Ufixed of Token.t (* "ufixed" *)
  | `Pat_accdbe2 of pat_accdbe2 (*tok*)
]
[@@deriving sexp_of]

type double_quoted_unicode_char = [
    `Pat_0c477de of pat_0c477de (*tok*)
  | `Esc_seq of escape_sequence (*tok*)
]
[@@deriving sexp_of]

type single_quoted_unicode_char = [
    `Pat_a096c41 of pat_a096c41 (*tok*)
  | `Esc_seq of escape_sequence (*tok*)
]
[@@deriving sexp_of]

type import_declaration = (
    identifier (*tok*)
  * (Token.t (* "as" *) * identifier (*tok*)) option
)
[@@deriving sexp_of]

type anon_id_rep_COMMA_id_opt_COMMA_e9ba3f8 = (
    identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
  * Token.t (* "," *) option
)
[@@deriving sexp_of]

type user_defined_type = (
    identifier (*tok*)
  * (Token.t (* "." *) * identifier (*tok*)) list (* zero or more *)
)
[@@deriving sexp_of]

type decimal_number = [
    `Pat_6c32705 of pat_6c32705 (*tok*)
  | `Pat_0468c4a of pat_0468c4a (*tok*)
]
[@@deriving sexp_of]

type anon_rep_opt___hex_digit_c87bea1 =
  (Token.t (* "_" *) option * hex_digit (*tok*)) list (* zero or more *)
[@@deriving sexp_of]

type string_ = [
    `DQUOT_rep_choice_imm_tok_pat_de5d470_DQUOT of (
        Token.t (* "\"" *)
      * [
            `Imm_tok_pat_de5d470 of imm_tok_pat_de5d470 (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `SQUOT_rep_choice_imm_tok_pat_3e57880_SQUOT of (
        Token.t (* "'" *)
      * [
            `Imm_tok_pat_3e57880 of imm_tok_pat_3e57880 (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "'" *)
    )
]
[@@deriving sexp_of]

type solidity_directive = (
    Token.t (* "solidity" *)
  * pragma_version_constraint list (* zero or more *)
)
[@@deriving sexp_of]

type primitive_type = [
    `Addr_opt_paya of (
        Token.t (* "address" *)
      * Token.t (* "payable" *) option
    )
  | `Bool of Token.t (* "bool" *)
  | `Str of Token.t (* "string" *)
  | `Var of Token.t (* "var" *)
  | `Int of int_
  | `Uint of uint
  | `Bytes of bytes_
  | `Fixed of fixed
  | `Ufixed of ufixed
]
[@@deriving sexp_of]

type unicode_string_literal =
  (
      Token.t (* "unicode" *)
    * [
          `DQUOT_rep_double_quoted_unic_char_DQUOT of (
              Token.t (* "\"" *)
            * double_quoted_unicode_char list (* zero or more *)
            * Token.t (* "\"" *)
          )
        | `SQUOT_rep_single_quoted_unic_char_SQUOT of (
              Token.t (* "'" *)
            * single_quoted_unicode_char list (* zero or more *)
            * Token.t (* "'" *)
          )
      ]
  )
    list (* one or more *)
[@@deriving sexp_of]

type enum_declaration = (
    Token.t (* "enum" *)
  * identifier (*tok*)
  * Token.t (* "{" *)
  * anon_id_rep_COMMA_id_opt_COMMA_e9ba3f8 option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type override_specifier = (
    Token.t (* "override" *)
  * (
        Token.t (* "(" *)
      * user_defined_type
      * (Token.t (* "," *) * user_defined_type) list (* zero or more *)
      * Token.t (* "," *) option
      * Token.t (* ")" *)
    )
      option
)
[@@deriving sexp_of]

type hex_number = (
    pat_923b015 (*tok*)
  * (hex_digit (*tok*) * anon_rep_opt___hex_digit_c87bea1) option
)
[@@deriving sexp_of]

type hex_string_literal =
  (
      Token.t (* "hex" *)
    * [
          `DQUOT_opt_hex_digit_rep_opt___hex_digit_DQUOT of (
              Token.t (* "\"" *)
            * (hex_digit (*tok*) * anon_rep_opt___hex_digit_c87bea1) option
            * Token.t (* "\"" *)
          )
        | `SQUOT_opt_hex_digit_rep_opt___hex_digit_SQUOT of (
              Token.t (* "'" *)
            * (hex_digit (*tok*) * anon_rep_opt___hex_digit_c87bea1) option
            * Token.t (* "'" *)
          )
      ]
  )
    list (* one or more *)
[@@deriving sexp_of]

type yul_string_literal = string_
[@@deriving sexp_of]

type mapping_key = [
    `Prim_type of primitive_type
  | `User_defi_type of user_defined_type
]
[@@deriving sexp_of]

type import_clause = [
    `Single_import of (
        Token.t (* "*" *)
      * (Token.t (* "as" *) * identifier (*tok*)) option
    )
  | `Mult_import of (
        Token.t (* "{" *)
      * (
            import_declaration
          * (Token.t (* "," *) * import_declaration) list (* zero or more *)
          * Token.t (* "," *) option
        )
          option
      * Token.t (* "}" *)
    )
]
[@@deriving sexp_of]

type string_literal = yul_string_literal list (* one or more *)
[@@deriving sexp_of]

type yul_literal = [
    `Yul_deci_num of yul_decimal_number (*tok*)
  | `Yul_str_lit of yul_string_literal
  | `Yul_hex_num of yul_hex_number (*tok*)
  | `Yul_bool of yul_boolean
]
[@@deriving sexp_of]

type source_import = (
    yul_string_literal
  * (Token.t (* "as" *) * identifier (*tok*)) option
)
[@@deriving sexp_of]

type from_clause = (Token.t (* "from" *) * yul_string_literal)
[@@deriving sexp_of]

type literal = [
    `Str_lit of string_literal
  | `Num_lit of (
        [ `Deci_num of decimal_number | `Hex_num of hex_number ]
      * number_unit option
    )
  | `Bool_lit of boolean_literal
  | `Hex_str_lit of hex_string_literal
  | `Unic_str_lit of unicode_string_literal
]
[@@deriving sexp_of]

type yul_expression = [
    `Yul_path of yul_path
  | `Yul_func_call of yul_function_call
  | `Yul_lit of yul_literal
]

and yul_function_call = (
    [ `Yul_id of yul_identifier (*tok*) | `Yul_evm_buil of yul_evm_builtin ]
  * Token.t (* "(" *)
  * (
        yul_expression
      * (Token.t (* "," *) * yul_expression) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type anon_choice_exp_e762ef6 = [
    `Exp of expression
  | `LCURL_opt_id_rep_COMMA_id_opt_COMMA_RCURL of (
        Token.t (* "{" *)
      * anon_id_rep_COMMA_id_opt_COMMA_e9ba3f8 option
      * Token.t (* "}" *)
    )
]

and array_access = (
    expression * Token.t (* "[" *) * expression * Token.t (* "]" *)
)

and binary_expression = [
    `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Exp_GTGT_exp of (expression * Token.t (* ">>" *) * expression)
  | `Exp_GTGTGT_exp of (expression * Token.t (* ">>>" *) * expression)
  | `Exp_LTLT_exp of (expression * Token.t (* "<<" *) * expression)
  | `Exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Exp_PLUS_exp of (expression * Token.t (* "+" *) * expression)
  | `Exp_DASH_exp of (expression * Token.t (* "-" *) * expression)
  | `Exp_STAR_exp of (expression * Token.t (* "*" *) * expression)
  | `Exp_SLASH_exp of (expression * Token.t (* "/" *) * expression)
  | `Exp_PERC_exp of (expression * Token.t (* "%" *) * expression)
  | `Exp_STARSTAR_exp of (expression * Token.t (* "**" *) * expression)
  | `Exp_LT_exp of (expression * Token.t (* "<" *) * expression)
  | `Exp_LTEQ_exp of (expression * Token.t (* "<=" *) * expression)
  | `Exp_EQEQ_exp of (expression * Token.t (* "==" *) * expression)
  | `Exp_BANGEQ_exp of (expression * Token.t (* "!=" *) * expression)
  | `Exp_BANGEQEQ_exp of (expression * Token.t (* "!==" *) * expression)
  | `Exp_GTEQ_exp of (expression * Token.t (* ">=" *) * expression)
  | `Exp_GT_exp of (expression * Token.t (* ">" *) * expression)
]

and call_arguments = (
    Token.t (* "(" *)
  * (
        anon_choice_exp_e762ef6
      * (Token.t (* "," *) * anon_choice_exp_e762ef6) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and expression = [
    `Bin_exp of binary_expression
  | `Un_exp of unary_expression
  | `Update_exp of update_expression
  | `Call_expr of (expression * call_arguments)
  | `Paya_conv_exp of (Token.t (* "payable" *) * call_arguments)
  | `Meta_type_exp of (
        Token.t (* "type" *) * Token.t (* "(" *) * type_name
      * Token.t (* ")" *)
    )
  | `Prim_exp of primary_expression
  | `Struct_exp of (
        expression
      * Token.t (* "{" *)
      * (
            identifier (*tok*)
          * Token.t (* ":" *)
          * expression
          * (
                Token.t (* "," *) * identifier (*tok*) * Token.t (* ":" *)
              * expression
            )
              list (* zero or more *)
          * Token.t (* "," *) option
        )
          option
      * Token.t (* "}" *)
    )
  | `Tern_exp of (
        expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
      * expression
    )
  | `Type_cast_exp of (
        primitive_type * Token.t (* "(" *) * expression * Token.t (* ")" *)
    )
]

and lhs_expression = [
    `Member_exp of member_expression
  | `Array_access of array_access
  | `Id of identifier (*tok*)
  | `Tuple_exp of tuple_expression
]

and member_expression = (
    [ `Exp of expression | `Id of identifier (*tok*) ]
  * Token.t (* "." *)
  * identifier (*tok*)
)

and nameless_parameter = (type_name * storage_location option)

and parameter = (
    type_name
  * storage_location option
  * identifier (*tok*) option
)

and parameter_list = (
    Token.t (* "(" *)
  * (
        parameter
      * (Token.t (* "," *) * parameter) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and parenthesized_expression = (
    Token.t (* "(" *) * expression * Token.t (* ")" *)
)

and primary_expression = [
    `Paren_exp of parenthesized_expression
  | `Member_exp of member_expression
  | `Array_access of array_access
  | `Slice_access of (
        expression * Token.t (* "[" *) * expression * Token.t (* ":" *)
      * expression * Token.t (* "]" *)
    )
  | `Prim_type of primitive_type
  | `Assign_exp of (
        [
            `Paren_exp of parenthesized_expression
          | `Lhs_exp of lhs_expression
        ]
      * Token.t (* "=" *)
      * expression
    )
  | `Augm_assign_exp of (
        lhs_expression
      * [
            `PLUSEQ of Token.t (* "+=" *)
          | `DASHEQ of Token.t (* "-=" *)
          | `STAREQ of Token.t (* "*=" *)
          | `SLASHEQ of Token.t (* "/=" *)
          | `PERCEQ of Token.t (* "%=" *)
          | `HATEQ of Token.t (* "^=" *)
          | `AMPEQ of Token.t (* "&=" *)
          | `BAREQ of Token.t (* "|=" *)
          | `GTGTEQ of Token.t (* ">>=" *)
          | `GTGTGTEQ of Token.t (* ">>>=" *)
          | `LTLTEQ of Token.t (* "<<=" *)
        ]
      * expression
    )
  | `User_defi_type of user_defined_type
  | `Tuple_exp of tuple_expression
  | `Inline_array_exp of (
        Token.t (* "[" *)
      * (
            expression
          * (Token.t (* "," *) * expression) list (* zero or more *)
          * Token.t (* "," *) option
        )
          option
      * Token.t (* "]" *)
    )
  | `Id of identifier (*tok*)
  | `Lit of literal
  | `New_exp of (Token.t (* "new" *) * type_name * call_arguments option)
]

and return_parameters = (
    Token.t (* "(" *)
  * nameless_parameter
  * (Token.t (* "," *) * nameless_parameter) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and tuple_expression = (
    Token.t (* "(" *)
  * expression option
  * (Token.t (* "," *) * expression option) list (* zero or more *)
  * Token.t (* ")" *)
)

and type_name = [
    `Prim_type of primitive_type
  | `User_defi_type of user_defined_type
  | `Mapp of (
        Token.t (* "mapping" *) * Token.t (* "(" *) * mapping_key
      * Token.t (* "=>" *) * type_name * Token.t (* ")" *)
    )
  | `Array_type of (
        type_name
      * Token.t (* "[" *)
      * expression option
      * Token.t (* "]" *)
    )
  | `Func_type of (
        Token.t (* "function" *)
      * parameter_list
      * return_parameters option
    )
]

and unary_expression = [
    `BANG_exp of (Token.t (* "!" *) * expression)
  | `TILDE_exp of (Token.t (* "~" *) * expression)
  | `DASH_exp of (Token.t (* "-" *) * expression)
  | `PLUS_exp of (Token.t (* "+" *) * expression)
  | `Delete_exp of (Token.t (* "delete" *) * expression)
]

and update_expression = [
    `Exp_choice_PLUSPLUS of (expression * anon_choice_PLUSPLUS_e498e28)
  | `Choice_PLUSPLUS_exp of (anon_choice_PLUSPLUS_e498e28 * expression)
]
[@@deriving sexp_of]

type yul_assignment = [
    `Yul_path_COLONEQ_yul_exp of (
        yul_path * Token.t (* ":=" *) * yul_expression
    )
  | `Yul_path_rep_COMMA_yul_path_opt_COMMA_opt_COLONEQ_yul_func_call of (
        yul_path
      * (Token.t (* "," *) * yul_path) list (* zero or more *)
      * Token.t (* "," *) option
      * (Token.t (* ":=" *) * yul_function_call) option
    )
]
[@@deriving sexp_of]

type yul_variable_declaration = [
    `Let_yul_id_opt_COLONEQ_yul_exp of (
        Token.t (* "let" *)
      * yul_identifier (*tok*)
      * (Token.t (* ":=" *) * yul_expression) option
    )
  | `Let_choice_yul_id_rep_COMMA_yul_id_opt_COMMA_opt_COLONEQ_yul_func_call of (
        Token.t (* "let" *)
      * [
            `Yul_id_rep_COMMA_yul_id_opt_COMMA of
              anon_yul_id_rep_COMMA_yul_id_opt_COMMA_477546e
          | `LPAR_yul_id_rep_COMMA_yul_id_opt_COMMA_RPAR of (
                Token.t (* "(" *)
              * yul_identifier (*tok*)
              * (Token.t (* "," *) * yul_identifier (*tok*))
                  list (* zero or more *)
              * Token.t (* "," *) option
              * Token.t (* ")" *)
            )
        ]
      * (Token.t (* ":=" *) * yul_function_call) option
    )
]
[@@deriving sexp_of]

type directive = [
    `Pragma_dire of (
        Token.t (* "pragma" *)
      * [
            `Soli_dire of solidity_directive
          | `Expe_dire of experimental_directive
        ]
      * Token.t (* ";" *)
    )
  | `Import_dire of (
        Token.t (* "import" *)
      * [
            `Source_import of source_import
          | `Import_clause_from_clause of (import_clause * from_clause)
        ]
      * Token.t (* ";" *)
    )
]
[@@deriving sexp_of]

type expression_statement = (expression * Token.t (* ";" *))
[@@deriving sexp_of]

type inheritance_specifier = (user_defined_type * call_arguments option)
[@@deriving sexp_of]

type struct_member = (type_name * identifier (*tok*) * Token.t (* ";" *))
[@@deriving sexp_of]

type modifier_invocation = (identifier (*tok*) * call_arguments option)
[@@deriving sexp_of]

type state_variable_declaration = (
    type_name
  * [
        `Visi of visibility
      | `Cst of Token.t (* "constant" *)
      | `Over_spec of override_specifier
      | `Immu of Token.t (* "immutable" *)
    ]
      list (* zero or more *)
  * identifier (*tok*)
  * (Token.t (* "=" *) * expression) option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type variable_declaration = (
    type_name
  * storage_location option
  * identifier (*tok*)
)
[@@deriving sexp_of]

type event_paramater = (
    type_name
  * Token.t (* "indexed" *) option
  * identifier (*tok*) option
)
[@@deriving sexp_of]

type using_directive = (
    Token.t (* "using" *)
  * user_defined_type
  * Token.t (* "for" *)
  * [ `Any_source_type of Token.t (* "*" *) | `Type_name of type_name ]
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type yul_block = (
    Token.t (* "{" *)
  * yul_statement list (* zero or more *)
  * Token.t (* "}" *)
)

and yul_statement = [
    `Yul_blk of yul_block
  | `Yul_var_decl of yul_variable_declaration
  | `Yul_assign of yul_assignment
  | `Yul_func_call of yul_function_call
  | `Yul_if_stmt of (Token.t (* "if" *) * yul_expression * yul_block)
  | `Yul_for_stmt of (
        Token.t (* "for" *) * yul_block * yul_expression * yul_block
      * yul_block
    )
  | `Yul_switch_stmt of (
        Token.t (* "switch" *)
      * yul_expression
      * [
            `Defa_yul_blk of (Token.t (* "default" *) * yul_block)
          | `Rep1_case_yul_lit_yul_blk_opt_defa_yul_blk of (
                (Token.t (* "case" *) * yul_literal * yul_block)
                  list (* one or more *)
              * (Token.t (* "default" *) * yul_block) option
            )
        ]
    )
  | `Yul_leave of Token.t (* "leave" *)
  | `Yul_brk of Token.t (* "break" *)
  | `Yul_cont of Token.t (* "continue" *)
  | `Yul_func_defi of (
        Token.t (* "function" *)
      * yul_identifier (*tok*)
      * Token.t (* "(" *)
      * anon_yul_id_rep_COMMA_yul_id_opt_COMMA_477546e option
      * Token.t (* ")" *)
      * (
            Token.t (* "->" *)
          * yul_identifier (*tok*)
          * (Token.t (* "," *) * yul_identifier (*tok*))
              list (* zero or more *)
          * Token.t (* "," *) option
        )
          option
      * yul_block
    )
]
[@@deriving sexp_of]

type class_heritage = (
    Token.t (* "is" *)
  * inheritance_specifier
  * (Token.t (* "," *) * inheritance_specifier) list (* zero or more *)
  * Token.t (* "," *) option
)
[@@deriving sexp_of]

type struct_declaration = (
    Token.t (* "struct" *)
  * identifier (*tok*)
  * Token.t (* "{" *)
  * struct_member list (* one or more *)
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type variable_declaration_tuple = [
    `LPAR_opt_var_decl_rep_COMMA_var_decl_opt_COMMA_RPAR of (
        Token.t (* "(" *)
      * (
            variable_declaration
          * (Token.t (* "," *) * variable_declaration)
              list (* zero or more *)
          * Token.t (* "," *) option
        )
          option
      * Token.t (* ")" *)
    )
  | `Var_LPAR_opt_id_rep_COMMA_opt_id_RPAR of (
        Token.t (* "var" *)
      * Token.t (* "(" *)
      * identifier (*tok*) option
      * (Token.t (* "," *) * identifier (*tok*) option)
          list (* zero or more *)
      * Token.t (* ")" *)
    )
]
[@@deriving sexp_of]

type event_parameter_list = (
    Token.t (* "(" *)
  * (
        event_paramater
      * (Token.t (* "," *) * event_paramater) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type variable_declaration_statement = (
    [
        `Var_decl_opt_EQ_exp of (
            variable_declaration
          * (Token.t (* "=" *) * expression) option
        )
      | `Var_decl_tuple_EQ_exp of (
            variable_declaration_tuple * Token.t (* "=" *) * expression
        )
    ]
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type event_definition = (
    Token.t (* "event" *)
  * identifier (*tok*)
  * event_parameter_list
  * Token.t (* "anonymous" *) option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type block_statement = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)

and catch_clause = (
    Token.t (* "catch" *)
  * (identifier (*tok*) option * parameter_list) option
  * block_statement
)

and statement = [
    `Blk_stmt of block_statement
  | `Exp_stmt of expression_statement
  | `Var_decl_stmt of variable_declaration_statement
  | `If_stmt of (
        Token.t (* "if" *)
      * Token.t (* "(" *)
      * expression
      * Token.t (* ")" *)
      * statement
      * (Token.t (* "else" *) * statement) option
    )
  | `For_stmt of (
        Token.t (* "for" *)
      * Token.t (* "(" *)
      * [
            `Var_decl_stmt of variable_declaration_statement
          | `Exp_stmt of expression_statement
          | `Semi of Token.t (* ";" *)
        ]
      * [ `Exp_stmt of expression_statement | `Semi of Token.t (* ";" *) ]
      * expression option
      * Token.t (* ")" *)
      * statement
    )
  | `While_stmt of (
        Token.t (* "while" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *) * statement
    )
  | `Do_while_stmt of (
        Token.t (* "do" *) * statement * Token.t (* "while" *)
      * Token.t (* "(" *) * expression * Token.t (* ")" *)
    )
  | `Cont_stmt of (Token.t (* "continue" *) * Token.t (* ";" *))
  | `Brk_stmt of (Token.t (* "break" *) * Token.t (* ";" *))
  | `Try_stmt of (
        Token.t (* "try" *)
      * expression
      * (Token.t (* "returns" *) * parameter_list) option
      * block_statement
      * catch_clause list (* one or more *)
    )
  | `Ret_stmt of (
        Token.t (* "return" *)
      * expression option
      * Token.t (* ";" *)
    )
  | `Emit_stmt of (
        Token.t (* "emit" *) * expression * call_arguments
      * Token.t (* ";" *)
    )
  | `Asse_stmt of (
        Token.t (* "assembly" *)
      * Token.t (* "\"evmasm\"" *) option
      * Token.t (* "{" *)
      * yul_statement list (* zero or more *)
      * Token.t (* "}" *)
    )
]
[@@deriving sexp_of]

type function_body = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type constructor_definition = (
    Token.t (* "constructor" *)
  * parameter_list
  * [
        `Modi_invo of modifier_invocation
      | `Paya of Token.t (* "payable" *)
      | `Choice_inte of [
            `Inte of Token.t (* "internal" *)
          | `Public of Token.t (* "public" *)
        ]
    ]
      list (* zero or more *)
  * function_body
)
[@@deriving sexp_of]

type anon_choice_semi_f2fe6be = [
    `Semi of Token.t (* ";" *)
  | `Func_body of function_body
]
[@@deriving sexp_of]

type modifier_definition = (
    Token.t (* "modifier" *)
  * identifier (*tok*)
  * parameter_list option
  * [ `Virt of Token.t (* "virtual" *) | `Over_spec of override_specifier ]
      list (* zero or more *)
  * anon_choice_semi_f2fe6be
)
[@@deriving sexp_of]

type function_definition = (
    Token.t (* "function" *)
  * identifier (*tok*)
  * parameter_list
  * [
        `Modi_invo of modifier_invocation
      | `Visi of visibility
      | `State_muta of state_mutability
      | `Virt of Token.t (* "virtual" *)
      | `Over_spec of override_specifier
    ]
      list (* zero or more *)
  * (Token.t (* "returns" *) * parameter_list) option
  * anon_choice_semi_f2fe6be
)
[@@deriving sexp_of]

type fallback_receive_definition = (
    [
        `Opt_func_choice_fall of (
            Token.t (* "function" *) option
          * [
                `Fall of Token.t (* "fallback" *)
              | `Rece of Token.t (* "receive" *)
            ]
        )
      | `Func of Token.t (* "function" *)
    ]
  * Token.t (* "(" *)
  * Token.t (* ")" *)
  * [
        `Visi of visibility
      | `Modi_invo of modifier_invocation
      | `State_muta of state_mutability
      | `Virt of Token.t (* "virtual" *)
      | `Over_spec of override_specifier
    ]
      list (* zero or more *)
  * anon_choice_semi_f2fe6be
)
[@@deriving sexp_of]

type contract_body = (
    Token.t (* "{" *)
  * [
        `Func_defi of function_definition
      | `Modi_defi of modifier_definition
      | `State_var_decl of state_variable_declaration
      | `Struct_decl of struct_declaration
      | `Enum_decl of enum_declaration
      | `Event_defi of event_definition
      | `Using_dire of using_directive
      | `Cons_defi of constructor_definition
      | `Fall_rece_defi of fallback_receive_definition
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type declaration = [
    `Cont_decl of (
        Token.t (* "abstract" *) option
      * Token.t (* "contract" *)
      * identifier (*tok*)
      * class_heritage option
      * contract_body
    )
  | `Inte_decl of (
        Token.t (* "interface" *)
      * identifier (*tok*)
      * class_heritage option
      * contract_body
    )
  | `Libr_decl of (
        Token.t (* "library" *) * identifier (*tok*) * contract_body
    )
  | `Struct_decl of struct_declaration
  | `Enum_decl of enum_declaration
  | `Func_defi of function_definition
  | `Cst_var_decl of (
        type_name * Token.t (* "constant" *) * identifier (*tok*)
      * Token.t (* "=" *) * expression * Token.t (* ";" *)
    )
]
[@@deriving sexp_of]

type source_unit = [ `Dire of directive | `Decl of declaration ]
[@@deriving sexp_of]

type source_file = source_unit list (* zero or more *)
[@@deriving sexp_of]

type true_ (* inlined *) = Token.t (* "true" *)
[@@deriving sexp_of]

type yul_break (* inlined *) = Token.t (* "break" *)
[@@deriving sexp_of]

type constant (* inlined *) = Token.t (* "constant" *)
[@@deriving sexp_of]

type yul_leave (* inlined *) = Token.t (* "leave" *)
[@@deriving sexp_of]

type any_source_type (* inlined *) = Token.t (* "*" *)
[@@deriving sexp_of]

type override (* inlined *) = Token.t (* "override" *)
[@@deriving sexp_of]

type number (* inlined *) = Token.t (* pattern \d+ *)
[@@deriving sexp_of]

type false_ (* inlined *) = Token.t (* "false" *)
[@@deriving sexp_of]

type semicolon (* inlined *) = Token.t (* ";" *)
[@@deriving sexp_of]

type immutable (* inlined *) = Token.t (* "immutable" *)
[@@deriving sexp_of]

type virtual_ (* inlined *) = Token.t (* "virtual" *)
[@@deriving sexp_of]

type yul_continue (* inlined *) = Token.t (* "continue" *)
[@@deriving sexp_of]

type comment (* inlined *) = Token.t
[@@deriving sexp_of]

type continue_statement (* inlined *) = (
    Token.t (* "continue" *) * Token.t (* ";" *)
)
[@@deriving sexp_of]

type break_statement (* inlined *) = (
    Token.t (* "break" *) * Token.t (* ";" *)
)
[@@deriving sexp_of]

type single_import (* inlined *) = (
    Token.t (* "*" *)
  * (Token.t (* "as" *) * identifier (*tok*)) option
)
[@@deriving sexp_of]

type multiple_import (* inlined *) = (
    Token.t (* "{" *)
  * (
        import_declaration
      * (Token.t (* "," *) * import_declaration) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type pragma_directive (* inlined *) = (
    Token.t (* "pragma" *)
  * [
        `Soli_dire of solidity_directive
      | `Expe_dire of experimental_directive
    ]
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type number_literal (* inlined *) = (
    [ `Deci_num of decimal_number | `Hex_num of hex_number ]
  * number_unit option
)
[@@deriving sexp_of]

type import_directive (* inlined *) = (
    Token.t (* "import" *)
  * [
        `Source_import of source_import
      | `Import_clause_from_clause of (import_clause * from_clause)
    ]
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type array_type (* inlined *) = (
    type_name
  * Token.t (* "[" *)
  * expression option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type assignment_expression (* inlined *) = (
    [ `Paren_exp of parenthesized_expression | `Lhs_exp of lhs_expression ]
  * Token.t (* "=" *)
  * expression
)
[@@deriving sexp_of]

type augmented_assignment_expression (* inlined *) = (
    lhs_expression
  * [
        `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `GTGTGTEQ of Token.t (* ">>>=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
    ]
  * expression
)
[@@deriving sexp_of]

type call_expresion (* inlined *) = (expression * call_arguments)
[@@deriving sexp_of]

type function_type (* inlined *) = (
    Token.t (* "function" *)
  * parameter_list
  * return_parameters option
)
[@@deriving sexp_of]

type inline_array_expression (* inlined *) = (
    Token.t (* "[" *)
  * (
        expression
      * (Token.t (* "," *) * expression) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type mapping (* inlined *) = (
    Token.t (* "mapping" *) * Token.t (* "(" *) * mapping_key
  * Token.t (* "=>" *) * type_name * Token.t (* ")" *)
)
[@@deriving sexp_of]

type meta_type_expression (* inlined *) = (
    Token.t (* "type" *) * Token.t (* "(" *) * type_name * Token.t (* ")" *)
)
[@@deriving sexp_of]

type new_expression (* inlined *) = (
    Token.t (* "new" *)
  * type_name
  * call_arguments option
)
[@@deriving sexp_of]

type payable_conversion_expression (* inlined *) = (
    Token.t (* "payable" *) * call_arguments
)
[@@deriving sexp_of]

type slice_access (* inlined *) = (
    expression * Token.t (* "[" *) * expression * Token.t (* ":" *)
  * expression * Token.t (* "]" *)
)
[@@deriving sexp_of]

type struct_expression (* inlined *) = (
    expression
  * Token.t (* "{" *)
  * (
        identifier (*tok*)
      * Token.t (* ":" *)
      * expression
      * (
            Token.t (* "," *) * identifier (*tok*) * Token.t (* ":" *)
          * expression
        )
          list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type ternary_expression (* inlined *) = (
    expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
  * expression
)
[@@deriving sexp_of]

type type_cast_expression (* inlined *) = (
    primitive_type * Token.t (* "(" *) * expression * Token.t (* ")" *)
)
[@@deriving sexp_of]

type constant_variable_declaration (* inlined *) = (
    type_name * Token.t (* "constant" *) * identifier (*tok*)
  * Token.t (* "=" *) * expression * Token.t (* ";" *)
)
[@@deriving sexp_of]

type return_statement (* inlined *) = (
    Token.t (* "return" *)
  * expression option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type emit_statement (* inlined *) = (
    Token.t (* "emit" *) * expression * call_arguments * Token.t (* ";" *)
)
[@@deriving sexp_of]

type yul_for_statement (* inlined *) = (
    Token.t (* "for" *) * yul_block * yul_expression * yul_block * yul_block
)
[@@deriving sexp_of]

type yul_function_definition (* inlined *) = (
    Token.t (* "function" *)
  * yul_identifier (*tok*)
  * Token.t (* "(" *)
  * anon_yul_id_rep_COMMA_yul_id_opt_COMMA_477546e option
  * Token.t (* ")" *)
  * (
        Token.t (* "->" *)
      * yul_identifier (*tok*)
      * (Token.t (* "," *) * yul_identifier (*tok*)) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * yul_block
)
[@@deriving sexp_of]

type yul_if_statement (* inlined *) = (
    Token.t (* "if" *) * yul_expression * yul_block
)
[@@deriving sexp_of]

type yul_switch_statement (* inlined *) = (
    Token.t (* "switch" *)
  * yul_expression
  * [
        `Defa_yul_blk of (Token.t (* "default" *) * yul_block)
      | `Rep1_case_yul_lit_yul_blk_opt_defa_yul_blk of (
            (Token.t (* "case" *) * yul_literal * yul_block)
              list (* one or more *)
          * (Token.t (* "default" *) * yul_block) option
        )
    ]
)
[@@deriving sexp_of]

type assembly_statement (* inlined *) = (
    Token.t (* "assembly" *)
  * Token.t (* "\"evmasm\"" *) option
  * Token.t (* "{" *)
  * yul_statement list (* zero or more *)
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type do_while_statement (* inlined *) = (
    Token.t (* "do" *) * statement * Token.t (* "while" *)
  * Token.t (* "(" *) * expression * Token.t (* ")" *)
)
[@@deriving sexp_of]

type for_statement (* inlined *) = (
    Token.t (* "for" *)
  * Token.t (* "(" *)
  * [
        `Var_decl_stmt of variable_declaration_statement
      | `Exp_stmt of expression_statement
      | `Semi of Token.t (* ";" *)
    ]
  * [ `Exp_stmt of expression_statement | `Semi of Token.t (* ";" *) ]
  * expression option
  * Token.t (* ")" *)
  * statement
)
[@@deriving sexp_of]

type if_statement (* inlined *) = (
    Token.t (* "if" *)
  * Token.t (* "(" *)
  * expression
  * Token.t (* ")" *)
  * statement
  * (Token.t (* "else" *) * statement) option
)
[@@deriving sexp_of]

type try_statement (* inlined *) = (
    Token.t (* "try" *)
  * expression
  * (Token.t (* "returns" *) * parameter_list) option
  * block_statement
  * catch_clause list (* one or more *)
)
[@@deriving sexp_of]

type while_statement (* inlined *) = (
    Token.t (* "while" *) * Token.t (* "(" *) * expression
  * Token.t (* ")" *) * statement
)
[@@deriving sexp_of]

type contract_declaration (* inlined *) = (
    Token.t (* "abstract" *) option
  * Token.t (* "contract" *)
  * identifier (*tok*)
  * class_heritage option
  * contract_body
)
[@@deriving sexp_of]

type library_declaration (* inlined *) = (
    Token.t (* "library" *) * identifier (*tok*) * contract_body
)
[@@deriving sexp_of]

type interface_declaration (* inlined *) = (
    Token.t (* "interface" *)
  * identifier (*tok*)
  * class_heritage option
  * contract_body
)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_source_file root
  |> Print_sexp.to_stdout

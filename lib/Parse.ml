(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_solidity"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
]

let children_regexps : (string * Run.exp option) list = [
  "storage_location",
  Some (
    Alt [|
      Token (Literal "memory");
      Token (Literal "storage");
      Token (Literal "calldata");
    |];
  );
  "yul_hex_number", None;
  "immutable", None;
  "number_unit",
  Some (
    Alt [|
      Token (Literal "wei");
      Token (Literal "szabo");
      Token (Literal "finney");
      Token (Literal "gwei");
      Token (Literal "ether");
      Token (Literal "seconds");
      Token (Literal "minutes");
      Token (Literal "hours");
      Token (Literal "days");
      Token (Literal "weeks");
      Token (Literal "years");
    |];
  );
  "pat_a096c41", None;
  "yul_evm_builtin",
  Some (
    Alt [|
      Token (Literal "stop");
      Token (Literal "add");
      Token (Literal "sub");
      Token (Literal "mul");
      Token (Literal "div");
      Token (Literal "sdiv");
      Token (Literal "mod");
      Token (Literal "smod");
      Token (Literal "exp");
      Token (Literal "not");
      Token (Literal "lt");
      Token (Literal "gt");
      Token (Literal "slt");
      Token (Literal "sgt");
      Token (Literal "eq");
      Token (Literal "iszero");
      Token (Literal "and");
      Token (Literal "or");
      Token (Literal "xor");
      Token (Literal "byte");
      Token (Literal "shl");
      Token (Literal "shr");
      Token (Literal "sar");
      Token (Literal "addmod");
      Token (Literal "mulmod");
      Token (Literal "signextend");
      Token (Literal "keccak256");
      Token (Literal "pop");
      Token (Literal "mload");
      Token (Literal "mstore");
      Token (Literal "mstore8");
      Token (Literal "sload");
      Token (Literal "sstore");
      Token (Literal "msize");
      Token (Literal "gas");
      Token (Literal "address");
      Token (Literal "balance");
      Token (Literal "selfbalance");
      Token (Literal "caller");
      Token (Literal "callvalue");
      Token (Literal "calldataload");
      Token (Literal "calldatasize");
      Token (Literal "calldatacopy");
      Token (Literal "extcodesize");
      Token (Literal "extcodecopy");
      Token (Literal "returndatasize");
      Token (Literal "returndatacopy");
      Token (Literal "extcodehash");
      Token (Literal "create");
      Token (Literal "create2");
      Token (Literal "call");
      Token (Literal "callcode");
      Token (Literal "delegatecall");
      Token (Literal "staticcall");
      Token (Literal "return");
      Token (Literal "revert");
      Token (Literal "selfdestruct");
      Token (Literal "invalid");
      Token (Literal "log0");
      Token (Literal "log1");
      Token (Literal "log2");
      Token (Literal "log3");
      Token (Literal "log4");
      Token (Literal "chainid");
      Token (Literal "origin");
      Token (Literal "gasprice");
      Token (Literal "blockhash");
      Token (Literal "coinbase");
      Token (Literal "timestamp");
      Token (Literal "number");
      Token (Literal "difficulty");
      Token (Literal "gaslimit");
    |];
  );
  "yul_leave", None;
  "pat_6c32705", None;
  "pat_0c477de", None;
  "bytes",
  Some (
    Alt [|
      Token (Literal "byte");
      Token (Literal "bytes");
      Token (Literal "bytes1");
      Token (Literal "bytes2");
      Token (Literal "bytes3");
      Token (Literal "bytes4");
      Token (Literal "bytes5");
      Token (Literal "bytes6");
      Token (Literal "bytes7");
      Token (Literal "bytes8");
      Token (Literal "bytes9");
      Token (Literal "bytes10");
      Token (Literal "bytes11");
      Token (Literal "bytes12");
      Token (Literal "bytes13");
      Token (Literal "bytes14");
      Token (Literal "bytes15");
      Token (Literal "bytes16");
      Token (Literal "bytes17");
      Token (Literal "bytes18");
      Token (Literal "bytes19");
      Token (Literal "bytes20");
      Token (Literal "bytes21");
      Token (Literal "bytes22");
      Token (Literal "bytes23");
      Token (Literal "bytes24");
      Token (Literal "bytes25");
      Token (Literal "bytes26");
      Token (Literal "bytes27");
      Token (Literal "bytes28");
      Token (Literal "bytes29");
      Token (Literal "bytes30");
      Token (Literal "bytes31");
      Token (Literal "bytes32");
    |];
  );
  "imm_tok_pat_3e57880", None;
  "pat_923b015", None;
  "uint",
  Some (
    Alt [|
      Token (Literal "uint");
      Token (Literal "uint8");
      Token (Literal "uint16");
      Token (Literal "uint24");
      Token (Literal "uint32");
      Token (Literal "uint40");
      Token (Literal "uint48");
      Token (Literal "uint56");
      Token (Literal "uint64");
      Token (Literal "uint72");
      Token (Literal "uint80");
      Token (Literal "uint88");
      Token (Literal "uint96");
      Token (Literal "uint104");
      Token (Literal "uint112");
      Token (Literal "uint120");
      Token (Literal "uint128");
      Token (Literal "uint136");
      Token (Literal "uint144");
      Token (Literal "uint152");
      Token (Literal "uint160");
      Token (Literal "uint168");
      Token (Literal "uint176");
      Token (Literal "uint184");
      Token (Literal "uint192");
      Token (Literal "uint200");
      Token (Literal "uint208");
      Token (Literal "uint216");
      Token (Literal "uint224");
      Token (Literal "uint232");
      Token (Literal "uint240");
      Token (Literal "uint248");
      Token (Literal "uint256");
    |];
  );
  "pat_0468c4a", None;
  "yul_decimal_number", None;
  "semicolon", None;
  "hex_digit", None;
  "solidity_version_comparison_operator",
  Some (
    Alt [|
      Token (Literal "<=");
      Token (Literal "<");
      Token (Literal "^");
      Token (Literal ">");
      Token (Literal ">=");
      Token (Literal "~");
      Token (Literal "=");
    |];
  );
  "int",
  Some (
    Alt [|
      Token (Literal "int");
      Token (Literal "int8");
      Token (Literal "int16");
      Token (Literal "int24");
      Token (Literal "int32");
      Token (Literal "int40");
      Token (Literal "int48");
      Token (Literal "int56");
      Token (Literal "int64");
      Token (Literal "int72");
      Token (Literal "int80");
      Token (Literal "int88");
      Token (Literal "int96");
      Token (Literal "int104");
      Token (Literal "int112");
      Token (Literal "int120");
      Token (Literal "int128");
      Token (Literal "int136");
      Token (Literal "int144");
      Token (Literal "int152");
      Token (Literal "int160");
      Token (Literal "int168");
      Token (Literal "int176");
      Token (Literal "int184");
      Token (Literal "int192");
      Token (Literal "int200");
      Token (Literal "int208");
      Token (Literal "int216");
      Token (Literal "int224");
      Token (Literal "int232");
      Token (Literal "int240");
      Token (Literal "int248");
      Token (Literal "int256");
    |];
  );
  "state_mutability",
  Some (
    Alt [|
      Token (Literal "pure");
      Token (Literal "view");
      Token (Literal "payable");
    |];
  );
  "solidity_version", None;
  "yul_break", None;
  "escape_sequence", None;
  "virtual", None;
  "identifier", None;
  "pat_f2662db", None;
  "true", None;
  "visibility",
  Some (
    Alt [|
      Token (Literal "public");
      Token (Literal "internal");
      Token (Literal "private");
      Token (Literal "external");
    |];
  );
  "yul_continue", None;
  "experimental_directives",
  Some (
    Alt [|
      Token (Literal "ABIEncoderV2");
      Token (Literal "SMTChecker");
    |];
  );
  "yul_boolean",
  Some (
    Alt [|
      Token (Literal "true");
      Token (Literal "false");
    |];
  );
  "yul_identifier", None;
  "any_source_type", None;
  "constant", None;
  "pat_accdbe2", None;
  "imm_tok_pat_de5d470", None;
  "false", None;
  "decimal_number",
  Some (
    Alt [|
      Token (Name "pat_6c32705");
      Token (Name "pat_0468c4a");
    |];
  );
  "continue_statement",
  Some (
    Seq [
      Token (Literal "continue");
      Token (Name "semicolon");
    ];
  );
  "break_statement",
  Some (
    Seq [
      Token (Literal "break");
      Token (Name "semicolon");
    ];
  );
  "hex_string_literal",
  Some (
    Repeat1 (
      Seq [
        Token (Literal "hex");
        Alt [|
          Seq [
            Token (Literal "\"");
            Opt (
              Seq [
                Token (Name "hex_digit");
                Repeat (
                  Seq [
                    Opt (
                      Token (Literal "_");
                    );
                    Token (Name "hex_digit");
                  ];
                );
              ];
            );
            Token (Literal "\"");
          ];
          Seq [
            Token (Literal "'");
            Opt (
              Seq [
                Token (Name "hex_digit");
                Repeat (
                  Seq [
                    Opt (
                      Token (Literal "_");
                    );
                    Token (Name "hex_digit");
                  ];
                );
              ];
            );
            Token (Literal "'");
          ];
        |];
      ];
    );
  );
  "hex_number",
  Some (
    Seq [
      Token (Name "pat_923b015");
      Opt (
        Seq [
          Token (Name "hex_digit");
          Repeat (
            Seq [
              Opt (
                Token (Literal "_");
              );
              Token (Name "hex_digit");
            ];
          );
        ];
      );
    ];
  );
  "pragma_version_constraint",
  Some (
    Seq [
      Opt (
        Token (Name "solidity_version_comparison_operator");
      );
      Token (Name "solidity_version");
    ];
  );
  "double_quoted_unicode_char",
  Some (
    Alt [|
      Token (Name "pat_0c477de");
      Token (Name "escape_sequence");
    |];
  );
  "single_quoted_unicode_char",
  Some (
    Alt [|
      Token (Name "pat_a096c41");
      Token (Name "escape_sequence");
    |];
  );
  "user_defined_type",
  Some (
    Seq [
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal ".");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "single_import",
  Some (
    Seq [
      Token (Literal "*");
      Opt (
        Seq [
          Token (Literal "as");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "import_declaration",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal "as");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "enum_declaration",
  Some (
    Seq [
      Token (Literal "enum");
      Token (Name "identifier");
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "identifier");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "identifier");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "fixed",
  Some (
    Alt [|
      Token (Literal "fixed");
      Token (Name "pat_f2662db");
    |];
  );
  "experimental_directive",
  Some (
    Seq [
      Token (Literal "experimental");
      Opt (
        Token (Literal "\"");
      );
      Token (Name "experimental_directives");
      Opt (
        Token (Literal "\"");
      );
    ];
  );
  "yul_path",
  Some (
    Seq [
      Token (Name "yul_identifier");
      Repeat (
        Seq [
          Token (Literal ".");
          Token (Name "yul_identifier");
        ];
      );
    ];
  );
  "ufixed",
  Some (
    Alt [|
      Token (Literal "ufixed");
      Token (Name "pat_accdbe2");
    |];
  );
  "string",
  Some (
    Alt [|
      Seq [
        Token (Literal "\"");
        Repeat (
          Alt [|
            Token (Name "imm_tok_pat_de5d470");
            Token (Name "escape_sequence");
          |];
        );
        Token (Literal "\"");
      ];
      Seq [
        Token (Literal "'");
        Repeat (
          Alt [|
            Token (Name "imm_tok_pat_3e57880");
            Token (Name "escape_sequence");
          |];
        );
        Token (Literal "'");
      ];
    |];
  );
  "boolean_literal",
  Some (
    Alt [|
      Token (Name "true");
      Token (Name "false");
    |];
  );
  "number_literal",
  Some (
    Seq [
      Alt [|
        Token (Name "decimal_number");
        Token (Name "hex_number");
      |];
      Opt (
        Token (Name "number_unit");
      );
    ];
  );
  "solidity_directive",
  Some (
    Seq [
      Token (Literal "solidity");
      Repeat (
        Token (Name "pragma_version_constraint");
      );
    ];
  );
  "unicode_string_literal",
  Some (
    Repeat1 (
      Seq [
        Token (Literal "unicode");
        Alt [|
          Seq [
            Token (Literal "\"");
            Repeat (
              Token (Name "double_quoted_unicode_char");
            );
            Token (Literal "\"");
          ];
          Seq [
            Token (Literal "'");
            Repeat (
              Token (Name "single_quoted_unicode_char");
            );
            Token (Literal "'");
          ];
        |];
      ];
    );
  );
  "override_specifier",
  Some (
    Seq [
      Token (Literal "override");
      Opt (
        Seq [
          Token (Literal "(");
          Token (Name "user_defined_type");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "user_defined_type");
            ];
          );
          Opt (
            Token (Literal ",");
          );
          Token (Literal ")");
        ];
      );
    ];
  );
  "multiple_import",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "import_declaration");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "import_declaration");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "primitive_type",
  Some (
    Alt [|
      Seq [
        Token (Literal "address");
        Opt (
          Token (Literal "payable");
        );
      ];
      Token (Literal "bool");
      Token (Literal "string");
      Token (Literal "var");
      Token (Name "int");
      Token (Name "uint");
      Token (Name "bytes");
      Token (Name "fixed");
      Token (Name "ufixed");
    |];
  );
  "string_literal",
  Some (
    Repeat1 (
      Token (Name "string");
    );
  );
  "from_clause",
  Some (
    Seq [
      Token (Literal "from");
      Token (Name "string");
    ];
  );
  "yul_string_literal", Some (Token (Name "string"););
  "source_import",
  Some (
    Seq [
      Token (Name "string");
      Opt (
        Seq [
          Token (Literal "as");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "pragma_directive",
  Some (
    Seq [
      Token (Literal "pragma");
      Alt [|
        Token (Name "solidity_directive");
        Token (Name "experimental_directive");
      |];
      Token (Name "semicolon");
    ];
  );
  "import_clause",
  Some (
    Alt [|
      Token (Name "single_import");
      Token (Name "multiple_import");
    |];
  );
  "mapping_key",
  Some (
    Alt [|
      Token (Name "primitive_type");
      Token (Name "user_defined_type");
    |];
  );
  "literal",
  Some (
    Alt [|
      Token (Name "string_literal");
      Token (Name "number_literal");
      Token (Name "boolean_literal");
      Token (Name "hex_string_literal");
      Token (Name "unicode_string_literal");
    |];
  );
  "yul_literal",
  Some (
    Alt [|
      Token (Name "yul_decimal_number");
      Token (Name "yul_string_literal");
      Token (Name "yul_hex_number");
      Token (Name "yul_boolean");
    |];
  );
  "import_directive",
  Some (
    Seq [
      Token (Literal "import");
      Alt [|
        Token (Name "source_import");
        Seq [
          Token (Name "import_clause");
          Token (Name "from_clause");
        ];
      |];
      Token (Name "semicolon");
    ];
  );
  "array_access",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "[");
      Token (Name "expression");
      Token (Literal "]");
    ];
  );
  "array_type",
  Some (
    Seq [
      Token (Name "type_name");
      Token (Literal "[");
      Opt (
        Token (Name "expression");
      );
      Token (Literal "]");
    ];
  );
  "assignment_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "parenthesized_expression");
        Token (Name "lhs_expression");
      |];
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "augmented_assignment_expression",
  Some (
    Seq [
      Token (Name "lhs_expression");
      Alt [|
        Token (Literal "+=");
        Token (Literal "-=");
        Token (Literal "*=");
        Token (Literal "/=");
        Token (Literal "%=");
        Token (Literal "^=");
        Token (Literal "&=");
        Token (Literal "|=");
        Token (Literal ">>=");
        Token (Literal ">>>=");
        Token (Literal "<<=");
      |];
      Token (Name "expression");
    ];
  );
  "binary_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Literal "&&");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "||");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">>");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">>>");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<<");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "&");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "^");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "|");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "+");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "-");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "*");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "/");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "%");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "**");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "==");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "!=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "!==");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">");
        Token (Name "expression");
      ];
    |];
  );
  "call_arguments",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Alt [|
            Token (Name "expression");
            Seq [
              Token (Literal "{");
              Opt (
                Seq [
                  Token (Name "identifier");
                  Repeat (
                    Seq [
                      Token (Literal ",");
                      Token (Name "identifier");
                    ];
                  );
                  Opt (
                    Token (Literal ",");
                  );
                ];
              );
              Token (Literal "}");
            ];
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "expression");
                Seq [
                  Token (Literal "{");
                  Opt (
                    Seq [
                      Token (Name "identifier");
                      Repeat (
                        Seq [
                          Token (Literal ",");
                          Token (Name "identifier");
                        ];
                      );
                      Opt (
                        Token (Literal ",");
                      );
                    ];
                  );
                  Token (Literal "}");
                ];
              |];
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "call_expresion",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "call_arguments");
    ];
  );
  "expression",
  Some (
    Alt [|
      Token (Name "binary_expression");
      Token (Name "unary_expression");
      Token (Name "update_expression");
      Token (Name "call_expresion");
      Token (Name "payable_conversion_expression");
      Token (Name "meta_type_expression");
      Token (Name "primary_expression");
      Token (Name "struct_expression");
      Token (Name "ternary_expression");
      Token (Name "type_cast_expression");
    |];
  );
  "function_type",
  Some (
    Seq [
      Token (Literal "function");
      Token (Name "parameter_list");
      Opt (
        Token (Name "return_parameters");
      );
    ];
  );
  "inline_array_expression",
  Some (
    Seq [
      Token (Literal "[");
      Opt (
        Seq [
          Token (Name "expression");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expression");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal "]");
    ];
  );
  "lhs_expression",
  Some (
    Alt [|
      Token (Name "member_expression");
      Token (Name "array_access");
      Token (Name "identifier");
      Token (Name "tuple_expression");
    |];
  );
  "mapping",
  Some (
    Seq [
      Token (Literal "mapping");
      Token (Literal "(");
      Token (Name "mapping_key");
      Token (Literal "=>");
      Token (Name "type_name");
      Token (Literal ")");
    ];
  );
  "member_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "expression");
        Token (Name "identifier");
      |];
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "meta_type_expression",
  Some (
    Seq [
      Token (Literal "type");
      Token (Literal "(");
      Token (Name "type_name");
      Token (Literal ")");
    ];
  );
  "nameless_parameter",
  Some (
    Seq [
      Token (Name "type_name");
      Opt (
        Token (Name "storage_location");
      );
    ];
  );
  "new_expression",
  Some (
    Seq [
      Token (Literal "new");
      Token (Name "type_name");
      Opt (
        Token (Name "call_arguments");
      );
    ];
  );
  "parameter",
  Some (
    Seq [
      Token (Name "type_name");
      Opt (
        Token (Name "storage_location");
      );
      Opt (
        Token (Name "identifier");
      );
    ];
  );
  "parameter_list",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "parameter");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "parameter");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "parenthesized_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "payable_conversion_expression",
  Some (
    Seq [
      Token (Literal "payable");
      Token (Name "call_arguments");
    ];
  );
  "primary_expression",
  Some (
    Alt [|
      Token (Name "parenthesized_expression");
      Token (Name "member_expression");
      Token (Name "array_access");
      Token (Name "slice_access");
      Token (Name "primitive_type");
      Token (Name "assignment_expression");
      Token (Name "augmented_assignment_expression");
      Token (Name "user_defined_type");
      Token (Name "tuple_expression");
      Token (Name "inline_array_expression");
      Token (Name "identifier");
      Token (Name "literal");
      Token (Name "new_expression");
    |];
  );
  "return_parameters",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "nameless_parameter");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "nameless_parameter");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ")");
    ];
  );
  "slice_access",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "[");
      Token (Name "expression");
      Token (Literal ":");
      Token (Name "expression");
      Token (Literal "]");
    ];
  );
  "struct_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "identifier");
          Token (Literal ":");
          Token (Name "expression");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "identifier");
              Token (Literal ":");
              Token (Name "expression");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "ternary_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "?");
      Token (Name "expression");
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "tuple_expression",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Token (Name "expression");
      );
      Repeat (
        Seq [
          Token (Literal ",");
          Opt (
            Token (Name "expression");
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "type_cast_expression",
  Some (
    Seq [
      Token (Name "primitive_type");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "type_name",
  Some (
    Alt [|
      Token (Name "primitive_type");
      Token (Name "user_defined_type");
      Token (Name "mapping");
      Token (Name "array_type");
      Token (Name "function_type");
    |];
  );
  "unary_expression",
  Some (
    Alt [|
      Seq [
        Token (Literal "!");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "~");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "-");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "+");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "delete");
        Token (Name "expression");
      ];
    |];
  );
  "update_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "++");
          Token (Literal "--");
        |];
      ];
      Seq [
        Alt [|
          Token (Literal "++");
          Token (Literal "--");
        |];
        Token (Name "expression");
      ];
    |];
  );
  "yul_expression",
  Some (
    Alt [|
      Token (Name "yul_path");
      Token (Name "yul_function_call");
      Token (Name "yul_literal");
    |];
  );
  "yul_function_call",
  Some (
    Seq [
      Alt [|
        Token (Name "yul_identifier");
        Token (Name "yul_evm_builtin");
      |];
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "yul_expression");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "yul_expression");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "directive",
  Some (
    Alt [|
      Token (Name "pragma_directive");
      Token (Name "import_directive");
    |];
  );
  "emit_statement",
  Some (
    Seq [
      Token (Literal "emit");
      Token (Name "expression");
      Token (Name "call_arguments");
      Token (Name "semicolon");
    ];
  );
  "using_directive",
  Some (
    Seq [
      Token (Literal "using");
      Token (Name "user_defined_type");
      Token (Literal "for");
      Alt [|
        Token (Name "any_source_type");
        Token (Name "type_name");
      |];
      Token (Name "semicolon");
    ];
  );
  "expression_statement",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "semicolon");
    ];
  );
  "state_variable_declaration",
  Some (
    Seq [
      Token (Name "type_name");
      Repeat (
        Alt [|
          Token (Name "visibility");
          Token (Name "constant");
          Token (Name "override_specifier");
          Token (Name "immutable");
        |];
      );
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      );
      Token (Name "semicolon");
    ];
  );
  "struct_member",
  Some (
    Seq [
      Token (Name "type_name");
      Token (Name "identifier");
      Token (Name "semicolon");
    ];
  );
  "event_paramater",
  Some (
    Seq [
      Token (Name "type_name");
      Opt (
        Token (Literal "indexed");
      );
      Opt (
        Token (Name "identifier");
      );
    ];
  );
  "inheritance_specifier",
  Some (
    Seq [
      Token (Name "user_defined_type");
      Opt (
        Token (Name "call_arguments");
      );
    ];
  );
  "variable_declaration",
  Some (
    Seq [
      Token (Name "type_name");
      Opt (
        Alt [|
          Token (Literal "memory");
          Token (Literal "storage");
          Token (Literal "calldata");
        |];
      );
      Token (Name "identifier");
    ];
  );
  "return_statement",
  Some (
    Seq [
      Token (Literal "return");
      Opt (
        Token (Name "expression");
      );
      Token (Name "semicolon");
    ];
  );
  "constant_variable_declaration",
  Some (
    Seq [
      Token (Name "type_name");
      Token (Name "constant");
      Token (Name "identifier");
      Token (Literal "=");
      Token (Name "expression");
      Token (Name "semicolon");
    ];
  );
  "modifier_invocation",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Token (Name "call_arguments");
      );
    ];
  );
  "yul_variable_declaration",
  Some (
    Alt [|
      Seq [
        Token (Literal "let");
        Token (Name "yul_identifier");
        Opt (
          Seq [
            Token (Literal ":=");
            Token (Name "yul_expression");
          ];
        );
      ];
      Seq [
        Token (Literal "let");
        Alt [|
          Seq [
            Token (Name "yul_identifier");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "yul_identifier");
              ];
            );
            Opt (
              Token (Literal ",");
            );
          ];
          Seq [
            Token (Literal "(");
            Token (Name "yul_identifier");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "yul_identifier");
              ];
            );
            Opt (
              Token (Literal ",");
            );
            Token (Literal ")");
          ];
        |];
        Opt (
          Seq [
            Token (Literal ":=");
            Token (Name "yul_function_call");
          ];
        );
      ];
    |];
  );
  "yul_assignment",
  Some (
    Alt [|
      Seq [
        Token (Name "yul_path");
        Token (Literal ":=");
        Token (Name "yul_expression");
      ];
      Seq [
        Token (Name "yul_path");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "yul_path");
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Opt (
          Seq [
            Token (Literal ":=");
            Token (Name "yul_function_call");
          ];
        );
      ];
    |];
  );
  "struct_declaration",
  Some (
    Seq [
      Token (Literal "struct");
      Token (Name "identifier");
      Token (Literal "{");
      Repeat1 (
        Token (Name "struct_member");
      );
      Token (Literal "}");
    ];
  );
  "event_parameter_list",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "event_paramater");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "event_paramater");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "class_heritage",
  Some (
    Seq [
      Token (Literal "is");
      Token (Name "inheritance_specifier");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "inheritance_specifier");
        ];
      );
      Opt (
        Token (Literal ",");
      );
    ];
  );
  "variable_declaration_tuple",
  Some (
    Alt [|
      Seq [
        Token (Literal "(");
        Opt (
          Seq [
            Token (Name "variable_declaration");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "variable_declaration");
              ];
            );
            Opt (
              Token (Literal ",");
            );
          ];
        );
        Token (Literal ")");
      ];
      Seq [
        Token (Literal "var");
        Token (Literal "(");
        Opt (
          Token (Name "identifier");
        );
        Repeat (
          Seq [
            Token (Literal ",");
            Opt (
              Token (Name "identifier");
            );
          ];
        );
        Token (Literal ")");
      ];
    |];
  );
  "yul_block",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "yul_statement");
      );
      Token (Literal "}");
    ];
  );
  "yul_for_statement",
  Some (
    Seq [
      Token (Literal "for");
      Token (Name "yul_block");
      Token (Name "yul_expression");
      Token (Name "yul_block");
      Token (Name "yul_block");
    ];
  );
  "yul_function_definition",
  Some (
    Seq [
      Token (Literal "function");
      Token (Name "yul_identifier");
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "yul_identifier");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "yul_identifier");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal ")");
      Opt (
        Seq [
          Token (Literal "->");
          Token (Name "yul_identifier");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "yul_identifier");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Name "yul_block");
    ];
  );
  "yul_if_statement",
  Some (
    Seq [
      Token (Literal "if");
      Token (Name "yul_expression");
      Token (Name "yul_block");
    ];
  );
  "yul_statement",
  Some (
    Alt [|
      Token (Name "yul_block");
      Token (Name "yul_variable_declaration");
      Token (Name "yul_assignment");
      Token (Name "yul_function_call");
      Token (Name "yul_if_statement");
      Token (Name "yul_for_statement");
      Token (Name "yul_switch_statement");
      Token (Name "yul_leave");
      Token (Name "yul_break");
      Token (Name "yul_continue");
      Token (Name "yul_function_definition");
    |];
  );
  "yul_switch_statement",
  Some (
    Seq [
      Token (Literal "switch");
      Token (Name "yul_expression");
      Alt [|
        Seq [
          Token (Literal "default");
          Token (Name "yul_block");
        ];
        Seq [
          Repeat1 (
            Seq [
              Token (Literal "case");
              Token (Name "yul_literal");
              Token (Name "yul_block");
            ];
          );
          Opt (
            Seq [
              Token (Literal "default");
              Token (Name "yul_block");
            ];
          );
        ];
      |];
    ];
  );
  "event_definition",
  Some (
    Seq [
      Token (Literal "event");
      Token (Name "identifier");
      Token (Name "event_parameter_list");
      Opt (
        Token (Literal "anonymous");
      );
      Token (Name "semicolon");
    ];
  );
  "variable_declaration_statement",
  Some (
    Seq [
      Alt [|
        Seq [
          Token (Name "variable_declaration");
          Opt (
            Seq [
              Token (Literal "=");
              Token (Name "expression");
            ];
          );
        ];
        Seq [
          Token (Name "variable_declaration_tuple");
          Token (Literal "=");
          Token (Name "expression");
        ];
      |];
      Token (Name "semicolon");
    ];
  );
  "assembly_statement",
  Some (
    Seq [
      Token (Literal "assembly");
      Opt (
        Token (Literal "\"evmasm\"");
      );
      Token (Literal "{");
      Repeat (
        Token (Name "yul_statement");
      );
      Token (Literal "}");
    ];
  );
  "block_statement",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "statement");
      );
      Token (Literal "}");
    ];
  );
  "catch_clause",
  Some (
    Seq [
      Token (Literal "catch");
      Opt (
        Seq [
          Opt (
            Token (Name "identifier");
          );
          Token (Name "parameter_list");
        ];
      );
      Token (Name "block_statement");
    ];
  );
  "do_while_statement",
  Some (
    Seq [
      Token (Literal "do");
      Token (Name "statement");
      Token (Literal "while");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "for_statement",
  Some (
    Seq [
      Token (Literal "for");
      Token (Literal "(");
      Alt [|
        Token (Name "variable_declaration_statement");
        Token (Name "expression_statement");
        Token (Name "semicolon");
      |];
      Alt [|
        Token (Name "expression_statement");
        Token (Name "semicolon");
      |];
      Opt (
        Token (Name "expression");
      );
      Token (Literal ")");
      Token (Name "statement");
    ];
  );
  "if_statement",
  Some (
    Seq [
      Token (Literal "if");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "statement");
      Opt (
        Seq [
          Token (Literal "else");
          Token (Name "statement");
        ];
      );
    ];
  );
  "statement",
  Some (
    Alt [|
      Token (Name "block_statement");
      Token (Name "expression_statement");
      Token (Name "variable_declaration_statement");
      Token (Name "if_statement");
      Token (Name "for_statement");
      Token (Name "while_statement");
      Token (Name "do_while_statement");
      Token (Name "continue_statement");
      Token (Name "break_statement");
      Token (Name "try_statement");
      Token (Name "return_statement");
      Token (Name "emit_statement");
      Token (Name "assembly_statement");
    |];
  );
  "try_statement",
  Some (
    Seq [
      Token (Literal "try");
      Token (Name "expression");
      Opt (
        Seq [
          Token (Literal "returns");
          Token (Name "parameter_list");
        ];
      );
      Token (Name "block_statement");
      Repeat1 (
        Token (Name "catch_clause");
      );
    ];
  );
  "while_statement",
  Some (
    Seq [
      Token (Literal "while");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "statement");
    ];
  );
  "function_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "statement");
      );
      Token (Literal "}");
    ];
  );
  "modifier_definition",
  Some (
    Seq [
      Token (Literal "modifier");
      Token (Name "identifier");
      Opt (
        Token (Name "parameter_list");
      );
      Repeat (
        Alt [|
          Token (Name "virtual");
          Token (Name "override_specifier");
        |];
      );
      Alt [|
        Token (Name "semicolon");
        Token (Name "function_body");
      |];
    ];
  );
  "fallback_receive_definition",
  Some (
    Seq [
      Alt [|
        Seq [
          Opt (
            Token (Literal "function");
          );
          Alt [|
            Token (Literal "fallback");
            Token (Literal "receive");
          |];
        ];
        Token (Literal "function");
      |];
      Token (Literal "(");
      Token (Literal ")");
      Repeat (
        Alt [|
          Token (Name "visibility");
          Token (Name "modifier_invocation");
          Token (Name "state_mutability");
          Token (Name "virtual");
          Token (Name "override_specifier");
        |];
      );
      Alt [|
        Token (Name "semicolon");
        Token (Name "function_body");
      |];
    ];
  );
  "function_definition",
  Some (
    Seq [
      Token (Literal "function");
      Token (Name "identifier");
      Token (Name "parameter_list");
      Repeat (
        Alt [|
          Token (Name "modifier_invocation");
          Token (Name "visibility");
          Token (Name "state_mutability");
          Token (Name "virtual");
          Token (Name "override_specifier");
        |];
      );
      Opt (
        Seq [
          Token (Literal "returns");
          Token (Name "parameter_list");
        ];
      );
      Alt [|
        Token (Name "semicolon");
        Token (Name "function_body");
      |];
    ];
  );
  "constructor_definition",
  Some (
    Seq [
      Token (Literal "constructor");
      Token (Name "parameter_list");
      Repeat (
        Alt [|
          Token (Name "modifier_invocation");
          Token (Literal "payable");
          Alt [|
            Token (Literal "internal");
            Token (Literal "public");
          |];
        |];
      );
      Token (Name "function_body");
    ];
  );
  "contract_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Alt [|
          Token (Name "function_definition");
          Token (Name "modifier_definition");
          Token (Name "state_variable_declaration");
          Token (Name "struct_declaration");
          Token (Name "enum_declaration");
          Token (Name "event_definition");
          Token (Name "using_directive");
          Token (Name "constructor_definition");
          Token (Name "fallback_receive_definition");
        |];
      );
      Token (Literal "}");
    ];
  );
  "contract_declaration",
  Some (
    Seq [
      Opt (
        Token (Literal "abstract");
      );
      Token (Literal "contract");
      Token (Name "identifier");
      Opt (
        Token (Name "class_heritage");
      );
      Token (Name "contract_body");
    ];
  );
  "library_declaration",
  Some (
    Seq [
      Token (Literal "library");
      Token (Name "identifier");
      Token (Name "contract_body");
    ];
  );
  "interface_declaration",
  Some (
    Seq [
      Token (Literal "interface");
      Token (Name "identifier");
      Opt (
        Token (Name "class_heritage");
      );
      Token (Name "contract_body");
    ];
  );
  "declaration",
  Some (
    Alt [|
      Token (Name "contract_declaration");
      Token (Name "interface_declaration");
      Token (Name "library_declaration");
      Token (Name "struct_declaration");
      Token (Name "enum_declaration");
      Token (Name "function_definition");
      Token (Name "constant_variable_declaration");
    |];
  );
  "source_unit",
  Some (
    Alt [|
      Token (Name "directive");
      Token (Name "declaration");
    |];
  );
  "source_file",
  Some (
    Seq [
      Repeat (
        Token (Name "source_unit");
      );
    ];
  );
]

let trans_storage_location ((kind, body) : mt) : CST.storage_location =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Memory (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Stor (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Call (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_yul_hex_number ((kind, body) : mt) : CST.yul_hex_number =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_immutable ((kind, body) : mt) : CST.immutable =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_number_unit ((kind, body) : mt) : CST.number_unit =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Wei (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Szabo (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Finney (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Gwei (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Ether (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Seconds (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Minutes (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Hours (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Days (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Weeks (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Years (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_a096c41 ((kind, body) : mt) : CST.pat_a096c41 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_yul_evm_builtin ((kind, body) : mt) : CST.yul_evm_builtin =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Stop (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Add (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Sub (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Mul (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Div (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Sdiv (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Mod (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Smod (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Exp (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Not (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Lt (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Gt (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Slt (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Sgt (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Eq (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Iszero (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `And (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Or (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Xor (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `Byte (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (20, v) ->
          `Shl (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (21, v) ->
          `Shr (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (22, v) ->
          `Sar (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (23, v) ->
          `Addmod (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (24, v) ->
          `Mulmod (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (25, v) ->
          `Sign (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (26, v) ->
          `Keccak256 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (27, v) ->
          `Pop (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (28, v) ->
          `Mload (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (29, v) ->
          `Mstore (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (30, v) ->
          `Mstore8 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (31, v) ->
          `Sload (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (32, v) ->
          `Sstore (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (33, v) ->
          `Msize (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (34, v) ->
          `Gas (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (35, v) ->
          `Addr (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (36, v) ->
          `Bala (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (37, v) ->
          `Self_e34af40 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (38, v) ->
          `Caller (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (39, v) ->
          `Call_17bffc7 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (40, v) ->
          `Call_b766e35 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (41, v) ->
          `Call_ee2b8b2 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (42, v) ->
          `Call_9211e8b (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (43, v) ->
          `Extc_8cf31ff (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (44, v) ->
          `Extc_097e5c5 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (45, v) ->
          `Retu_6316777 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (46, v) ->
          `Retu_0c570b4 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (47, v) ->
          `Extc_d7340e7 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (48, v) ->
          `Create (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (49, v) ->
          `Create2 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (50, v) ->
          `Call_53b9e96 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (51, v) ->
          `Call_bebd5bc (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (52, v) ->
          `Dele (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (53, v) ->
          `Stat (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (54, v) ->
          `Ret (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (55, v) ->
          `Revert (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (56, v) ->
          `Self_482b767 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (57, v) ->
          `Inva (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (58, v) ->
          `Log0 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (59, v) ->
          `Log1 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (60, v) ->
          `Log2 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (61, v) ->
          `Log3 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (62, v) ->
          `Log4 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (63, v) ->
          `Chai (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (64, v) ->
          `Origin (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (65, v) ->
          `Gasp (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (66, v) ->
          `Bloc (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (67, v) ->
          `Coin (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (68, v) ->
          `Time (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (69, v) ->
          `Num (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (70, v) ->
          `Diff (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (71, v) ->
          `Gasl (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_yul_leave ((kind, body) : mt) : CST.yul_leave =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_6c32705 ((kind, body) : mt) : CST.pat_6c32705 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_0c477de ((kind, body) : mt) : CST.pat_0c477de =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_bytes_ ((kind, body) : mt) : CST.bytes_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Byte (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bytes (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Bytes1 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Bytes2 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Bytes3 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Bytes4 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Bytes5 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Bytes6 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Bytes7 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Bytes8 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Bytes9 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Bytes10 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Bytes11 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Bytes12 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Bytes13 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Bytes14 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Bytes15 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Bytes16 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Bytes17 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `Bytes18 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (20, v) ->
          `Bytes19 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (21, v) ->
          `Bytes20 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (22, v) ->
          `Bytes21 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (23, v) ->
          `Bytes22 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (24, v) ->
          `Bytes23 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (25, v) ->
          `Bytes24 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (26, v) ->
          `Bytes25 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (27, v) ->
          `Bytes26 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (28, v) ->
          `Bytes27 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (29, v) ->
          `Bytes28 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (30, v) ->
          `Bytes29 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (31, v) ->
          `Bytes30 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (32, v) ->
          `Bytes31 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (33, v) ->
          `Bytes32 (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_imm_tok_pat_3e57880 ((kind, body) : mt) : CST.imm_tok_pat_3e57880 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_923b015 ((kind, body) : mt) : CST.pat_923b015 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_uint ((kind, body) : mt) : CST.uint =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Uint (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Uint8 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Uint16 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Uint24 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Uint32 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Uint40 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Uint48 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Uint56 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Uint64 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Uint72 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Uint80 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Uint88 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Uint96 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Uint104 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Uint112 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Uint120 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Uint128 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Uint136 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Uint144 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `Uint152 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (20, v) ->
          `Uint160 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (21, v) ->
          `Uint168 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (22, v) ->
          `Uint176 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (23, v) ->
          `Uint184 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (24, v) ->
          `Uint192 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (25, v) ->
          `Uint200 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (26, v) ->
          `Uint208 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (27, v) ->
          `Uint216 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (28, v) ->
          `Uint224 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (29, v) ->
          `Uint232 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (30, v) ->
          `Uint240 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (31, v) ->
          `Uint248 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (32, v) ->
          `Uint256 (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_0468c4a ((kind, body) : mt) : CST.pat_0468c4a =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_yul_decimal_number ((kind, body) : mt) : CST.yul_decimal_number =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semicolon ((kind, body) : mt) : CST.semicolon =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_hex_digit ((kind, body) : mt) : CST.hex_digit =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_solidity_version_comparison_operator ((kind, body) : mt) : CST.solidity_version_comparison_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `LT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `HAT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `GT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `GTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `TILDE (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `EQ (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_int_ ((kind, body) : mt) : CST.int_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Int (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Int8 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Int16 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Int24 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Int32 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Int40 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Int48 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Int56 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Int64 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Int72 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Int80 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Int88 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Int96 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Int104 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Int112 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Int120 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Int128 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Int136 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Int144 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `Int152 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (20, v) ->
          `Int160 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (21, v) ->
          `Int168 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (22, v) ->
          `Int176 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (23, v) ->
          `Int184 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (24, v) ->
          `Int192 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (25, v) ->
          `Int200 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (26, v) ->
          `Int208 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (27, v) ->
          `Int216 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (28, v) ->
          `Int224 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (29, v) ->
          `Int232 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (30, v) ->
          `Int240 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (31, v) ->
          `Int248 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (32, v) ->
          `Int256 (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_state_mutability ((kind, body) : mt) : CST.state_mutability =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pure (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `View (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Paya (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_solidity_version ((kind, body) : mt) : CST.solidity_version =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_yul_break ((kind, body) : mt) : CST.yul_break =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_escape_sequence ((kind, body) : mt) : CST.escape_sequence =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_virtual_ ((kind, body) : mt) : CST.virtual_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_f2662db ((kind, body) : mt) : CST.pat_f2662db =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_true_ ((kind, body) : mt) : CST.true_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_visibility ((kind, body) : mt) : CST.visibility =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Public (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Inte (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Priv (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Exte (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_yul_continue ((kind, body) : mt) : CST.yul_continue =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_experimental_directives ((kind, body) : mt) : CST.experimental_directives =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `ABIE2 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `SMTC (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_yul_boolean ((kind, body) : mt) : CST.yul_boolean =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `True (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `False (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_yul_identifier ((kind, body) : mt) : CST.yul_identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_any_source_type ((kind, body) : mt) : CST.any_source_type =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_constant ((kind, body) : mt) : CST.constant =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_accdbe2 ((kind, body) : mt) : CST.pat_accdbe2 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_imm_tok_pat_de5d470 ((kind, body) : mt) : CST.imm_tok_pat_de5d470 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_false_ ((kind, body) : mt) : CST.false_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_decimal_number ((kind, body) : mt) : CST.decimal_number =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_6c32705 (
            trans_pat_6c32705 (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_0468c4a (
            trans_pat_0468c4a (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_continue_statement ((kind, body) : mt) : CST.continue_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_semicolon (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_break_statement ((kind, body) : mt) : CST.break_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_semicolon (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_hex_string_literal ((kind, body) : mt) : CST.hex_string_literal =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Seq [v0; v1] ->
              (
                Run.trans_token (Run.matcher_token v0),
                (match v1 with
                | Alt (0, v) ->
                    `DQUOT_opt_hex_digit_rep_opt___hex_digit_DQUOT (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            Run.opt
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      trans_hex_digit (Run.matcher_token v0),
                                      Run.repeat
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1] ->
                                              (
                                                Run.opt
                                                  (fun v -> Run.trans_token (Run.matcher_token v))
                                                  v0
                                                ,
                                                trans_hex_digit (Run.matcher_token v1)
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            Run.trans_token (Run.matcher_token v2)
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `SQUOT_opt_hex_digit_rep_opt___hex_digit_SQUOT (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            Run.opt
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      trans_hex_digit (Run.matcher_token v0),
                                      Run.repeat
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1] ->
                                              (
                                                Run.opt
                                                  (fun v -> Run.trans_token (Run.matcher_token v))
                                                  v0
                                                ,
                                                trans_hex_digit (Run.matcher_token v1)
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            Run.trans_token (Run.matcher_token v2)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

let trans_hex_number ((kind, body) : mt) : CST.hex_number =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_923b015 (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_hex_digit (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.opt
                                  (fun v -> Run.trans_token (Run.matcher_token v))
                                  v0
                                ,
                                trans_hex_digit (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pragma_version_constraint ((kind, body) : mt) : CST.pragma_version_constraint =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v ->
                trans_solidity_version_comparison_operator (Run.matcher_token v)
              )
              v0
            ,
            trans_solidity_version (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_double_quoted_unicode_char ((kind, body) : mt) : CST.double_quoted_unicode_char =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_0c477de (
            trans_pat_0c477de (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Esc_seq (
            trans_escape_sequence (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_single_quoted_unicode_char ((kind, body) : mt) : CST.single_quoted_unicode_char =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_a096c41 (
            trans_pat_a096c41 (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Esc_seq (
            trans_escape_sequence (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_user_defined_type ((kind, body) : mt) : CST.user_defined_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_single_import ((kind, body) : mt) : CST.single_import =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_import_declaration ((kind, body) : mt) : CST.import_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_enum_declaration ((kind, body) : mt) : CST.enum_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_identifier (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_identifier (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_fixed ((kind, body) : mt) : CST.fixed =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Fixed (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_f2662db (
            trans_pat_f2662db (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_experimental_directive ((kind, body) : mt) : CST.experimental_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            trans_experimental_directives (Run.matcher_token v2),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_yul_path ((kind, body) : mt) : CST.yul_path =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_yul_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_yul_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_ufixed ((kind, body) : mt) : CST.ufixed =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Ufixed (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_accdbe2 (
            trans_pat_accdbe2 (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_string_ ((kind, body) : mt) : CST.string_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `DQUOT_rep_choice_imm_tok_pat_de5d470_DQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Imm_tok_pat_de5d470 (
                            trans_imm_tok_pat_de5d470 (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Esc_seq (
                            trans_escape_sequence (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `SQUOT_rep_choice_imm_tok_pat_3e57880_SQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Imm_tok_pat_3e57880 (
                            trans_imm_tok_pat_3e57880 (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Esc_seq (
                            trans_escape_sequence (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_boolean_literal ((kind, body) : mt) : CST.boolean_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `True (
            trans_true_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `False (
            trans_false_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_number_literal ((kind, body) : mt) : CST.number_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Deci_num (
                  trans_decimal_number (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Hex_num (
                  trans_hex_number (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_number_unit (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_solidity_directive ((kind, body) : mt) : CST.solidity_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                trans_pragma_version_constraint (Run.matcher_token v)
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_unicode_string_literal ((kind, body) : mt) : CST.unicode_string_literal =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Seq [v0; v1] ->
              (
                Run.trans_token (Run.matcher_token v0),
                (match v1 with
                | Alt (0, v) ->
                    `DQUOT_rep_double_quoted_unic_char_DQUOT (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                trans_double_quoted_unicode_char (Run.matcher_token v)
                              )
                              v1
                            ,
                            Run.trans_token (Run.matcher_token v2)
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `SQUOT_rep_single_quoted_unic_char_SQUOT (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                trans_single_quoted_unicode_char (Run.matcher_token v)
                              )
                              v1
                            ,
                            Run.trans_token (Run.matcher_token v2)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

let trans_override_specifier ((kind, body) : mt) : CST.override_specifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3; v4] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_user_defined_type (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_user_defined_type (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v3
                      ,
                      Run.trans_token (Run.matcher_token v4)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_multiple_import ((kind, body) : mt) : CST.multiple_import =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_import_declaration (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_import_declaration (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_primitive_type ((kind, body) : mt) : CST.primitive_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Addr_opt_paya (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Bool (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Str (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Var (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Int (
            trans_int_ (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Uint (
            trans_uint (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Bytes (
            trans_bytes_ (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Fixed (
            trans_fixed (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Ufixed (
            trans_ufixed (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_string_literal ((kind, body) : mt) : CST.string_literal =
  match body with
  | Children v ->
      Run.repeat1
        (fun v -> trans_string_ (Run.matcher_token v))
        v
  | Leaf _ -> assert false

let trans_from_clause ((kind, body) : mt) : CST.from_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_string_ (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_yul_string_literal ((kind, body) : mt) : CST.yul_string_literal =
  match body with
  | Children v ->
      trans_string_ (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_source_import ((kind, body) : mt) : CST.source_import =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_string_ (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pragma_directive ((kind, body) : mt) : CST.pragma_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Soli_dire (
                  trans_solidity_directive (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Expe_dire (
                  trans_experimental_directive (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_import_clause ((kind, body) : mt) : CST.import_clause =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Single_import (
            trans_single_import (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Mult_import (
            trans_multiple_import (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_mapping_key ((kind, body) : mt) : CST.mapping_key =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Prim_type (
            trans_primitive_type (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `User_defi_type (
            trans_user_defined_type (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_literal ((kind, body) : mt) : CST.literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Num_lit (
            trans_number_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Bool_lit (
            trans_boolean_literal (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Hex_str_lit (
            trans_hex_string_literal (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Unic_str_lit (
            trans_unicode_string_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_yul_literal ((kind, body) : mt) : CST.yul_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Yul_deci_num (
            trans_yul_decimal_number (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Yul_str_lit (
            trans_yul_string_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Yul_hex_num (
            trans_yul_hex_number (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Yul_bool (
            trans_yul_boolean (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_import_directive ((kind, body) : mt) : CST.import_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Source_import (
                  trans_source_import (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Import_clause_from_clause (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_import_clause (Run.matcher_token v0),
                        trans_from_clause (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_array_access ((kind, body) : mt) : CST.array_access =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_type ((kind, body) : mt) : CST.array_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_type_name (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assignment_expression ((kind, body) : mt) : CST.assignment_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Paren_exp (
                  trans_parenthesized_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Lhs_exp (
                  trans_lhs_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_augmented_assignment_expression ((kind, body) : mt) : CST.augmented_assignment_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_lhs_expression (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `PLUSEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `DASHEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `STAREQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `SLASHEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `PERCEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `HATEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `AMPEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `BAREQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (8, v) ->
                `GTGTEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (9, v) ->
                `GTGTGTEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (10, v) ->
                `LTLTEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_binary_expression ((kind, body) : mt) : CST.binary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_AMPAMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_BARBAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Exp_GTGT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Exp_GTGTGT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Exp_LTLT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Exp_AMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Exp_HAT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Exp_BAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Exp_PLUS_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Exp_DASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (10, v) ->
          `Exp_STAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (11, v) ->
          `Exp_SLASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (12, v) ->
          `Exp_PERC_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (13, v) ->
          `Exp_STARSTAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (14, v) ->
          `Exp_LT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (15, v) ->
          `Exp_LTEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (16, v) ->
          `Exp_EQEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (17, v) ->
          `Exp_BANGEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (18, v) ->
          `Exp_BANGEQEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (19, v) ->
          `Exp_GTEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (20, v) ->
          `Exp_GT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_arguments ((kind, body) : mt) : CST.call_arguments =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `LCURL_opt_id_rep_COMMA_id_opt_COMMA_RCURL (
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  Run.opt
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1; v2] ->
                                          (
                                            trans_identifier (Run.matcher_token v0),
                                            Run.repeat
                                              (fun v ->
                                                (match v with
                                                | Seq [v0; v1] ->
                                                    (
                                                      Run.trans_token (Run.matcher_token v0),
                                                      trans_identifier (Run.matcher_token v1)
                                                    )
                                                | _ -> assert false
                                                )
                                              )
                                              v1
                                            ,
                                            Run.opt
                                              (fun v -> Run.trans_token (Run.matcher_token v))
                                              v2
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                  ,
                                  Run.trans_token (Run.matcher_token v2)
                                )
                            | _ -> assert false
                            )
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Exp (
                                      trans_expression (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `LCURL_opt_id_rep_COMMA_id_opt_COMMA_RCURL (
                                      (match v with
                                      | Seq [v0; v1; v2] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            Run.opt
                                              (fun v ->
                                                (match v with
                                                | Seq [v0; v1; v2] ->
                                                    (
                                                      trans_identifier (Run.matcher_token v0),
                                                      Run.repeat
                                                        (fun v ->
                                                          (match v with
                                                          | Seq [v0; v1] ->
                                                              (
                                                                Run.trans_token (Run.matcher_token v0),
                                                                trans_identifier (Run.matcher_token v1)
                                                              )
                                                          | _ -> assert false
                                                          )
                                                        )
                                                        v1
                                                      ,
                                                      Run.opt
                                                        (fun v -> Run.trans_token (Run.matcher_token v))
                                                        v2
                                                    )
                                                | _ -> assert false
                                                )
                                              )
                                              v1
                                            ,
                                            Run.trans_token (Run.matcher_token v2)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_expresion ((kind, body) : mt) : CST.call_expresion =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_call_arguments (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Bin_exp (
            trans_binary_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Un_exp (
            trans_unary_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Update_exp (
            trans_update_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Call_expr (
            trans_call_expresion (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Paya_conv_exp (
            trans_payable_conversion_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Meta_type_exp (
            trans_meta_type_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Prim_exp (
            trans_primary_expression (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Struct_exp (
            trans_struct_expression (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Tern_exp (
            trans_ternary_expression (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Type_cast_exp (
            trans_type_cast_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_type ((kind, body) : mt) : CST.function_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_parameter_list (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_return_parameters (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_inline_array_expression ((kind, body) : mt) : CST.inline_array_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_expression (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_expression (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_lhs_expression ((kind, body) : mt) : CST.lhs_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Member_exp (
            trans_member_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Array_access (
            trans_array_access (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Tuple_exp (
            trans_tuple_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_mapping ((kind, body) : mt) : CST.mapping =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_mapping_key (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_type_name (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_member_expression ((kind, body) : mt) : CST.member_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_meta_type_expression ((kind, body) : mt) : CST.meta_type_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_type_name (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_nameless_parameter ((kind, body) : mt) : CST.nameless_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_type_name (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_storage_location (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_new_expression ((kind, body) : mt) : CST.new_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_name (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_call_arguments (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parameter ((kind, body) : mt) : CST.parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_type_name (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_storage_location (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_identifier (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parameter_list ((kind, body) : mt) : CST.parameter_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_parameter (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_parameter (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parenthesized_expression ((kind, body) : mt) : CST.parenthesized_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_payable_conversion_expression ((kind, body) : mt) : CST.payable_conversion_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_call_arguments (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_primary_expression ((kind, body) : mt) : CST.primary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Paren_exp (
            trans_parenthesized_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Member_exp (
            trans_member_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Array_access (
            trans_array_access (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Slice_access (
            trans_slice_access (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Prim_type (
            trans_primitive_type (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Assign_exp (
            trans_assignment_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Augm_assign_exp (
            trans_augmented_assignment_expression (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `User_defi_type (
            trans_user_defined_type (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Tuple_exp (
            trans_tuple_expression (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Inline_array_exp (
            trans_inline_array_expression (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Lit (
            trans_literal (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `New_exp (
            trans_new_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_return_parameters ((kind, body) : mt) : CST.return_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_nameless_parameter (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_nameless_parameter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_slice_access ((kind, body) : mt) : CST.slice_access =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_struct_expression ((kind, body) : mt) : CST.struct_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3; v4] ->
                    (
                      trans_identifier (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1),
                      trans_expression (Run.matcher_token v2),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1; v2; v3] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_identifier (Run.matcher_token v1),
                                Run.trans_token (Run.matcher_token v2),
                                trans_expression (Run.matcher_token v3)
                              )
                          | _ -> assert false
                          )
                        )
                        v3
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v4
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ternary_expression ((kind, body) : mt) : CST.ternary_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_tuple_expression ((kind, body) : mt) : CST.tuple_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v1
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.opt
                        (fun v -> trans_expression (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_cast_expression ((kind, body) : mt) : CST.type_cast_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_primitive_type (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_name ((kind, body) : mt) : CST.type_name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Prim_type (
            trans_primitive_type (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `User_defi_type (
            trans_user_defined_type (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Mapp (
            trans_mapping (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Array_type (
            trans_array_type (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Func_type (
            trans_function_type (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_expression ((kind, body) : mt) : CST.unary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `BANG_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `TILDE_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `DASH_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `PLUS_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Delete_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_update_expression ((kind, body) : mt) : CST.update_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_choice_PLUSPLUS (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `PLUSPLUS (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `DASHDASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Choice_PLUSPLUS_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `PLUSPLUS (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `DASHDASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_yul_expression ((kind, body) : mt) : CST.yul_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Yul_path (
            trans_yul_path (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Yul_func_call (
            trans_yul_function_call (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Yul_lit (
            trans_yul_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_yul_function_call ((kind, body) : mt) : CST.yul_function_call =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Yul_id (
                  trans_yul_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Yul_evm_buil (
                  trans_yul_evm_builtin (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_yul_expression (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_yul_expression (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_directive ((kind, body) : mt) : CST.directive =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pragma_dire (
            trans_pragma_directive (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Import_dire (
            trans_import_directive (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_emit_statement ((kind, body) : mt) : CST.emit_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            trans_call_arguments (Run.matcher_token v2),
            trans_semicolon (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_using_directive ((kind, body) : mt) : CST.using_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_user_defined_type (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Any_source_type (
                  trans_any_source_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type_name (
                  trans_type_name (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_semicolon (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_expression_statement ((kind, body) : mt) : CST.expression_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_semicolon (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_state_variable_declaration ((kind, body) : mt) : CST.state_variable_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_type_name (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Visi (
                      trans_visibility (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Cst (
                      trans_constant (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Over_spec (
                      trans_override_specifier (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Immu (
                      trans_immutable (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            trans_semicolon (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_struct_member ((kind, body) : mt) : CST.struct_member =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_type_name (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_event_paramater ((kind, body) : mt) : CST.event_paramater =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_type_name (Run.matcher_token v0),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_identifier (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_inheritance_specifier ((kind, body) : mt) : CST.inheritance_specifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_user_defined_type (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_call_arguments (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_variable_declaration ((kind, body) : mt) : CST.variable_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_type_name (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Memory (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Stor (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Call (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_return_statement ((kind, body) : mt) : CST.return_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v1
            ,
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_constant_variable_declaration ((kind, body) : mt) : CST.constant_variable_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            trans_type_name (Run.matcher_token v0),
            trans_constant (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            trans_semicolon (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_modifier_invocation ((kind, body) : mt) : CST.modifier_invocation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_call_arguments (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_yul_variable_declaration ((kind, body) : mt) : CST.yul_variable_declaration =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Let_yul_id_opt_COLONEQ_yul_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_yul_identifier (Run.matcher_token v1),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_yul_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Let_choice_yul_id_rep_COMMA_yul_id_opt_COMMA_opt_COLONEQ_yul_func_call (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `Yul_id_rep_COMMA_yul_id_opt_COMMA (
                        (match v with
                        | Seq [v0; v1; v2] ->
                            (
                              trans_yul_identifier (Run.matcher_token v0),
                              Run.repeat
                                (fun v ->
                                  (match v with
                                  | Seq [v0; v1] ->
                                      (
                                        Run.trans_token (Run.matcher_token v0),
                                        trans_yul_identifier (Run.matcher_token v1)
                                      )
                                  | _ -> assert false
                                  )
                                )
                                v1
                              ,
                              Run.opt
                                (fun v -> Run.trans_token (Run.matcher_token v))
                                v2
                            )
                        | _ -> assert false
                        )
                      )
                  | Alt (1, v) ->
                      `LPAR_yul_id_rep_COMMA_yul_id_opt_COMMA_RPAR (
                        (match v with
                        | Seq [v0; v1; v2; v3; v4] ->
                            (
                              Run.trans_token (Run.matcher_token v0),
                              trans_yul_identifier (Run.matcher_token v1),
                              Run.repeat
                                (fun v ->
                                  (match v with
                                  | Seq [v0; v1] ->
                                      (
                                        Run.trans_token (Run.matcher_token v0),
                                        trans_yul_identifier (Run.matcher_token v1)
                                      )
                                  | _ -> assert false
                                  )
                                )
                                v2
                              ,
                              Run.opt
                                (fun v -> Run.trans_token (Run.matcher_token v))
                                v3
                              ,
                              Run.trans_token (Run.matcher_token v4)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_yul_function_call (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_yul_assignment ((kind, body) : mt) : CST.yul_assignment =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Yul_path_COLONEQ_yul_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_yul_path (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_yul_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Yul_path_rep_COMMA_yul_path_opt_COMMA_opt_COLONEQ_yul_func_call (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  trans_yul_path (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_yul_path (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v2
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_yul_function_call (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_struct_declaration ((kind, body) : mt) : CST.struct_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.repeat1
              (fun v -> trans_struct_member (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_event_parameter_list ((kind, body) : mt) : CST.event_parameter_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_event_paramater (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_event_paramater (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_class_heritage ((kind, body) : mt) : CST.class_heritage =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_inheritance_specifier (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_inheritance_specifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_variable_declaration_tuple ((kind, body) : mt) : CST.variable_declaration_tuple =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LPAR_opt_var_decl_rep_COMMA_var_decl_opt_COMMA_RPAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            trans_variable_declaration (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_variable_declaration (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            Run.opt
                              (fun v -> Run.trans_token (Run.matcher_token v))
                              v2
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Var_LPAR_opt_id_rep_COMMA_opt_id_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_identifier (Run.matcher_token v))
                    v2
                  ,
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            Run.opt
                              (fun v -> trans_identifier (Run.matcher_token v))
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                  ,
                  Run.trans_token (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_yul_block ((kind, body) : mt) : CST.yul_block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_yul_statement (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_yul_for_statement ((kind, body) : mt) : CST.yul_for_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_yul_block (Run.matcher_token v1),
            trans_yul_expression (Run.matcher_token v2),
            trans_yul_block (Run.matcher_token v3),
            trans_yul_block (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_yul_function_definition ((kind, body) : mt) : CST.yul_function_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_yul_identifier (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_yul_identifier (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_yul_identifier (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_yul_identifier (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_yul_identifier (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v3
                    )
                | _ -> assert false
                )
              )
              v5
            ,
            trans_yul_block (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_yul_if_statement ((kind, body) : mt) : CST.yul_if_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_yul_expression (Run.matcher_token v1),
            trans_yul_block (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_yul_statement ((kind, body) : mt) : CST.yul_statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Yul_blk (
            trans_yul_block (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Yul_var_decl (
            trans_yul_variable_declaration (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Yul_assign (
            trans_yul_assignment (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Yul_func_call (
            trans_yul_function_call (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Yul_if_stmt (
            trans_yul_if_statement (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Yul_for_stmt (
            trans_yul_for_statement (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Yul_switch_stmt (
            trans_yul_switch_statement (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Yul_leave (
            trans_yul_leave (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Yul_brk (
            trans_yul_break (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Yul_cont (
            trans_yul_continue (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Yul_func_defi (
            trans_yul_function_definition (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_yul_switch_statement ((kind, body) : mt) : CST.yul_switch_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_yul_expression (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Defa_yul_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_yul_block (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Rep1_case_yul_lit_yul_blk_opt_defa_yul_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.repeat1
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_yul_literal (Run.matcher_token v1),
                                  trans_yul_block (Run.matcher_token v2)
                                )
                            | _ -> assert false
                            )
                          )
                          v0
                        ,
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_yul_block (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_event_definition ((kind, body) : mt) : CST.event_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            trans_event_parameter_list (Run.matcher_token v2),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            trans_semicolon (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_variable_declaration_statement ((kind, body) : mt) : CST.variable_declaration_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Var_decl_opt_EQ_exp (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_variable_declaration (Run.matcher_token v0),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_expression (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Var_decl_tuple_EQ_exp (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        trans_variable_declaration_tuple (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        trans_expression (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            trans_semicolon (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_assembly_statement ((kind, body) : mt) : CST.assembly_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            Run.repeat
              (fun v -> trans_yul_statement (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_block_statement ((kind, body) : mt) : CST.block_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_catch_clause ((kind, body) : mt) : CST.catch_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.opt
                        (fun v -> trans_identifier (Run.matcher_token v))
                        v0
                      ,
                      trans_parameter_list (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_block_statement (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_do_while_statement ((kind, body) : mt) : CST.do_while_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_statement (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_statement ((kind, body) : mt) : CST.for_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Var_decl_stmt (
                  trans_variable_declaration_statement (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Exp_stmt (
                  trans_expression_statement (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Semi (
                  trans_semicolon (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v3 with
            | Alt (0, v) ->
                `Exp_stmt (
                  trans_expression_statement (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Semi (
                  trans_semicolon (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5),
            trans_statement (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_statement ((kind, body) : mt) : CST.if_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_statement (Run.matcher_token v4),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_statement (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v5
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_statement ((kind, body) : mt) : CST.statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Blk_stmt (
            trans_block_statement (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Exp_stmt (
            trans_expression_statement (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Var_decl_stmt (
            trans_variable_declaration_statement (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `If_stmt (
            trans_if_statement (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `For_stmt (
            trans_for_statement (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `While_stmt (
            trans_while_statement (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Do_while_stmt (
            trans_do_while_statement (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Cont_stmt (
            trans_continue_statement (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Brk_stmt (
            trans_break_statement (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Try_stmt (
            trans_try_statement (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Ret_stmt (
            trans_return_statement (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Emit_stmt (
            trans_emit_statement (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Asse_stmt (
            trans_assembly_statement (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_try_statement ((kind, body) : mt) : CST.try_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_parameter_list (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_block_statement (Run.matcher_token v3),
            Run.repeat1
              (fun v -> trans_catch_clause (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_while_statement ((kind, body) : mt) : CST.while_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_statement (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_function_body ((kind, body) : mt) : CST.function_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_modifier_definition ((kind, body) : mt) : CST.modifier_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_parameter_list (Run.matcher_token v))
              v2
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Virt (
                      trans_virtual_ (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Over_spec (
                      trans_override_specifier (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            (match v4 with
            | Alt (0, v) ->
                `Semi (
                  trans_semicolon (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Func_body (
                  trans_function_body (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_fallback_receive_definition ((kind, body) : mt) : CST.fallback_receive_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Opt_func_choice_fall (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.opt
                          (fun v -> Run.trans_token (Run.matcher_token v))
                          v0
                        ,
                        (match v1 with
                        | Alt (0, v) ->
                            `Fall (
                              Run.trans_token (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Rece (
                              Run.trans_token (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Func (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Visi (
                      trans_visibility (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Modi_invo (
                      trans_modifier_invocation (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `State_muta (
                      trans_state_mutability (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Virt (
                      trans_virtual_ (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Over_spec (
                      trans_override_specifier (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            (match v4 with
            | Alt (0, v) ->
                `Semi (
                  trans_semicolon (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Func_body (
                  trans_function_body (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_function_definition ((kind, body) : mt) : CST.function_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            trans_parameter_list (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Modi_invo (
                      trans_modifier_invocation (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Visi (
                      trans_visibility (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `State_muta (
                      trans_state_mutability (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Virt (
                      trans_virtual_ (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Over_spec (
                      trans_override_specifier (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_parameter_list (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
            ,
            (match v5 with
            | Alt (0, v) ->
                `Semi (
                  trans_semicolon (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Func_body (
                  trans_function_body (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_constructor_definition ((kind, body) : mt) : CST.constructor_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_parameter_list (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Modi_invo (
                      trans_modifier_invocation (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Paya (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Choice_inte (
                      (match v with
                      | Alt (0, v) ->
                          `Inte (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Public (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_function_body (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_contract_body ((kind, body) : mt) : CST.contract_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Func_defi (
                      trans_function_definition (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Modi_defi (
                      trans_modifier_definition (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `State_var_decl (
                      trans_state_variable_declaration (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Struct_decl (
                      trans_struct_declaration (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Enum_decl (
                      trans_enum_declaration (Run.matcher_token v)
                    )
                | Alt (5, v) ->
                    `Event_defi (
                      trans_event_definition (Run.matcher_token v)
                    )
                | Alt (6, v) ->
                    `Using_dire (
                      trans_using_directive (Run.matcher_token v)
                    )
                | Alt (7, v) ->
                    `Cons_defi (
                      trans_constructor_definition (Run.matcher_token v)
                    )
                | Alt (8, v) ->
                    `Fall_rece_defi (
                      trans_fallback_receive_definition (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_contract_declaration ((kind, body) : mt) : CST.contract_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_class_heritage (Run.matcher_token v))
              v3
            ,
            trans_contract_body (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_library_declaration ((kind, body) : mt) : CST.library_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            trans_contract_body (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_interface_declaration ((kind, body) : mt) : CST.interface_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_class_heritage (Run.matcher_token v))
              v2
            ,
            trans_contract_body (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_declaration ((kind, body) : mt) : CST.declaration =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Cont_decl (
            trans_contract_declaration (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Inte_decl (
            trans_interface_declaration (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Libr_decl (
            trans_library_declaration (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Struct_decl (
            trans_struct_declaration (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Enum_decl (
            trans_enum_declaration (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Func_defi (
            trans_function_definition (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Cst_var_decl (
            trans_constant_variable_declaration (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_source_unit ((kind, body) : mt) : CST.source_unit =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Dire (
            trans_directive (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Decl (
            trans_declaration (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_source_file ((kind, body) : mt) : CST.source_file =
  match body with
  | Children v ->
      (match v with
      | Seq [v0] ->
          (
            Run.repeat
              (fun v -> trans_source_unit (Run.matcher_token v))
              v0
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_source_file matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

